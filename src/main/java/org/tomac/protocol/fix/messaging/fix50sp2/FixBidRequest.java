package org.tomac.protocol.fix.messaging.fix50sp2;

// DO NOT EDIT!!!
// This file is generated by FixMessageGenerator.
// If you need additional functionality, put it in a helper class
// that does not live in this folder!!!  Any java file in this folder 
// will be deleted upon the next run of the FixMessageGenerator!

import java.nio.ByteBuffer;

import org.tomac.protocol.fix.FixUtils;
import org.tomac.protocol.fix.FixSessionException;
import org.tomac.utils.Utils;
import org.tomac.protocol.fix.FixConstants;



public class FixBidRequest extends FixMessage
{

	public byte[] bidID;
	public byte[] clientBidID;
	public byte bidRequestTransType = (byte)' ';
	public byte[] listName;
	public long totNoRelatedSym = 0;
	public long bidType = 0;
	public long numTickets = 0;
	public byte[] currency;
	public long sideValue1 = 0;
	public long sideValue2 = 0;
	public long liquidityIndType = 0;
	public long wtAverageLiquidity = 0;
	public boolean exchangeForPhysical = false;
	public long outMainCntryUIndex = 0;
	public long crossPercent = 0;
	public long progRptReqs = 0;
	public long progPeriodInterval = 0;
	public long incTaxInd = 0;
	public boolean forexReq = false;
	public long numBidders = 0;
	public byte[] tradeDate;
	public byte bidTradeType = (byte)' ';
	public byte basisPxType = (byte)' ';
	public byte[] strikeTime;
	public byte[] text;
	public long encodedTextLen = 0;
	public byte[] encodedText;

	public FixBidRequest() {
		super();

		bidID = new byte[FixUtils.FIX_MAX_STRING_LENGTH];
		clientBidID = new byte[FixUtils.FIX_MAX_STRING_LENGTH];
		listName = new byte[FixUtils.FIX_MAX_STRING_LENGTH];
		currency = new byte[FixUtils.CURRENCY_LENGTH];
		tradeDate = new byte[FixUtils.FIX_MAX_STRING_LENGTH];
		strikeTime = new byte[FixUtils.UTCTIMESTAMP_LENGTH];
		text = new byte[FixUtils.FIX_MAX_STRING_TEXT_LENGTH];
		encodedText = new byte[FixUtils.FIX_MAX_STRING_TEXT_LENGTH];
		this.clear();

		msgType = MsgTypes.BIDREQUEST_INT;

	}

	@Override
	public void clear()
	{

		// clear out all the fields that aren't msgType

		Utils.fill( bidID, (byte)0 );
		Utils.fill( clientBidID, (byte)0 );
		bidRequestTransType = Byte.MAX_VALUE;		
		Utils.fill( listName, (byte)0 );
		totNoRelatedSym = Long.MAX_VALUE;		
		bidType = Long.MAX_VALUE;		
		numTickets = Long.MAX_VALUE;		
		Utils.fill( currency, (byte)0 );
		sideValue1 = Long.MAX_VALUE;		
		sideValue2 = Long.MAX_VALUE;		
		liquidityIndType = Long.MAX_VALUE;		
		wtAverageLiquidity = Long.MAX_VALUE;		
		exchangeForPhysical = false;		
		outMainCntryUIndex = Long.MAX_VALUE;		
		crossPercent = Long.MAX_VALUE;		
		progRptReqs = Long.MAX_VALUE;		
		progPeriodInterval = Long.MAX_VALUE;		
		incTaxInd = Long.MAX_VALUE;		
		forexReq = false;		
		numBidders = Long.MAX_VALUE;		
		Utils.fill( tradeDate, (byte)0 );
		bidTradeType = Byte.MAX_VALUE;		
		basisPxType = Byte.MAX_VALUE;		
		Utils.fill( strikeTime, (byte)0 );
		Utils.fill( text, (byte)0 );
		encodedTextLen = Long.MAX_VALUE;		
		Utils.fill( encodedText, (byte)0 );
	}

	@Override
	public void getAll() throws FixSessionException, IllegalStateException
	{

		int startTagPosition = buf.position();

		super.getAll();

		// assumption message is full otherwise decode would return null
		// so negative id means that we are at the end of the message
		int id;
		int lastTagPosition = buf.position();
		while ( ( id = FixUtils.getTagId( buf ) ) > 0 )
		{
			ByteBuffer value;

			value = buf;

			switch( id ) {

			case FixTags.BIDID_INT:
				bidID = FixUtils.getTagStringValue(value, bidID);
				break;

			case FixTags.CLIENTBIDID_INT:
				clientBidID = FixUtils.getTagStringValue(value, clientBidID);
				break;

			case FixTags.BIDREQUESTTRANSTYPE_INT:
				bidRequestTransType = FixUtils.getTagCharValue( value );
				if (!BidRequestTransType.isValid(bidRequestTransType) ) throw new FixSessionException(buf, "Invalid enumerated value(" + bidRequestTransType + ") for tag: " + id );
				break;

			case FixTags.LISTNAME_INT:
				listName = FixUtils.getTagStringValue(value, listName);
				break;

			case FixTags.TOTNORELATEDSYM_INT:
				totNoRelatedSym = FixUtils.getTagIntValue( value );
				break;

			case FixTags.BIDTYPE_INT:
				bidType = FixUtils.getTagIntValue( value );
				if (!BidType.isValid(bidType) ) throw new FixSessionException(buf, "Invalid enumerated value(" + bidType + ") for tag: " + id );
				break;

			case FixTags.NUMTICKETS_INT:
				numTickets = FixUtils.getTagIntValue( value );
				break;

			case FixTags.CURRENCY_INT:
				currency = FixUtils.getTagStringValue(value, currency);
				break;

			case FixTags.SIDEVALUE1_INT:
				sideValue1 = FixUtils.getTagFloatValue(value);
				break;

			case FixTags.SIDEVALUE2_INT:
				sideValue2 = FixUtils.getTagFloatValue(value);
				break;

			case FixTags.LIQUIDITYINDTYPE_INT:
				liquidityIndType = FixUtils.getTagIntValue( value );
				if (!LiquidityIndType.isValid(liquidityIndType) ) throw new FixSessionException(buf, "Invalid enumerated value(" + liquidityIndType + ") for tag: " + id );
				break;

			case FixTags.WTAVERAGELIQUIDITY_INT:
				wtAverageLiquidity = FixUtils.getTagFloatValue(value);
				break;

			case FixTags.EXCHANGEFORPHYSICAL_INT:
				exchangeForPhysical = FixUtils.getTagBooleanValue( value );
				if (!ExchangeForPhysical.isValid(exchangeForPhysical) ) throw new FixSessionException(buf, "Invalid enumerated value(" + exchangeForPhysical + ") for tag: " + id );
				break;

			case FixTags.OUTMAINCNTRYUINDEX_INT:
				outMainCntryUIndex = FixUtils.getTagFloatValue(value);
				break;

			case FixTags.CROSSPERCENT_INT:
				crossPercent = FixUtils.getTagFloatValue(value);
				break;

			case FixTags.PROGRPTREQS_INT:
				progRptReqs = FixUtils.getTagIntValue( value );
				if (!ProgRptReqs.isValid(progRptReqs) ) throw new FixSessionException(buf, "Invalid enumerated value(" + progRptReqs + ") for tag: " + id );
				break;

			case FixTags.PROGPERIODINTERVAL_INT:
				progPeriodInterval = FixUtils.getTagIntValue( value );
				break;

			case FixTags.INCTAXIND_INT:
				incTaxInd = FixUtils.getTagIntValue( value );
				if (!IncTaxInd.isValid(incTaxInd) ) throw new FixSessionException(buf, "Invalid enumerated value(" + incTaxInd + ") for tag: " + id );
				break;

			case FixTags.FOREXREQ_INT:
				forexReq = FixUtils.getTagBooleanValue( value );
				if (!ForexReq.isValid(forexReq) ) throw new FixSessionException(buf, "Invalid enumerated value(" + forexReq + ") for tag: " + id );
				break;

			case FixTags.NUMBIDDERS_INT:
				numBidders = FixUtils.getTagIntValue( value );
				break;

			case FixTags.TRADEDATE_INT:
				tradeDate = FixUtils.getTagStringValue(value, tradeDate);
				break;

			case FixTags.BIDTRADETYPE_INT:
				bidTradeType = FixUtils.getTagCharValue( value );
				if (!BidTradeType.isValid(bidTradeType) ) throw new FixSessionException(buf, "Invalid enumerated value(" + bidTradeType + ") for tag: " + id );
				break;

			case FixTags.BASISPXTYPE_INT:
				basisPxType = FixUtils.getTagCharValue( value );
				if (!BasisPxType.isValid(basisPxType) ) throw new FixSessionException(buf, "Invalid enumerated value(" + basisPxType + ") for tag: " + id );
				break;

			case FixTags.STRIKETIME_INT:
				strikeTime = FixUtils.getTagStringValue(value, strikeTime);
				break;

			case FixTags.TEXT_INT:
				text = FixUtils.getTagStringValue(value, text);
				break;

			case FixTags.ENCODEDTEXTLEN_INT:
				encodedTextLen = FixUtils.getTagIntValue( value );
				break;

			case FixTags.ENCODEDTEXT_INT:
				encodedText = FixUtils.getTagStringValue(value, encodedText);
				break;

			// for a message always get the checksum
			case FixTags.CHECKSUM_INT:
				checkSum = FixUtils.getTagIntValue( value );

				id = checkRequiredTags();
				if (id > 0) throw new FixSessionException(buf, "Required tag missing: " + id );

				return;

			default:
				throw new FixSessionException(buf, "Unknown tag: " + id );

			}

			lastTagPosition = buf.position();

		}

		buf.position(startTagPosition);

	}

	private int checkRequiredTags() {
		int tag = -1;

		if (! FixUtils.isSet(clientBidID) ) return FixTags.CLIENTBIDID_INT;
		if (! FixUtils.isSet(bidRequestTransType) ) return FixTags.BIDREQUESTTRANSTYPE_INT;
		if (! FixUtils.isSet(totNoRelatedSym) ) return FixTags.TOTNORELATEDSYM_INT;
		if (! FixUtils.isSet(bidType) ) return FixTags.BIDTYPE_INT;
		if (! FixUtils.isSet(bidTradeType) ) return FixTags.BIDTRADETYPE_INT;
		if (! FixUtils.isSet(basisPxType) ) return FixTags.BASISPXTYPE_INT;
		return tag;

	}
	@Override
	public void encode( ByteBuffer out )
	{
		// Encode message. Set msgSeqNum and sendingTime and optional resend flags, before encoding. 

		int msgStart = out.position();

		out.put( BEGINSTRING_VALUE_WITH_TAG );

		int msgLengthValueStart = out.position() + 2 /* 9= */;

		// placeholder
		FixUtils.putFixTag(out, FixTags.BODYLENGTH_INT, FixConstants.MAX_MESSAGE_SIZE );

		int msgTypeStart = out.position();

		FixUtils.putFixTag( out, FixTags.MSGTYPE_INT, MsgTypes.BIDREQUEST);

		// encode all fields including the header

		if (FixUtils.isSet(applVerID)) FixUtils.putFixTag( out, FixTags.APPLVERID_INT, applVerID, 0, Utils.lastIndexTrim(applVerID, (byte)0) );
		if (FixUtils.isSet(cstmApplVerID)) FixUtils.putFixTag( out, FixTags.CSTMAPPLVERID_INT, cstmApplVerID, 0, Utils.lastIndexTrim(cstmApplVerID, (byte)0) );
		if (FixUtils.isSet(applExtID)) FixUtils.putFixTag( out, FixTags.APPLEXTID_INT, applExtID);
		FixUtils.putFixTag( out, FixTags.SENDERCOMPID_INT, senderCompID, 0, Utils.lastIndexTrim(senderCompID, (byte)0) );
		FixUtils.putFixTag( out, FixTags.TARGETCOMPID_INT, targetCompID, 0, Utils.lastIndexTrim(targetCompID, (byte)0) );
		if (FixUtils.isSet(onBehalfOfCompID)) FixUtils.putFixTag( out, FixTags.ONBEHALFOFCOMPID_INT, onBehalfOfCompID, 0, Utils.lastIndexTrim(onBehalfOfCompID, (byte)0) );
		if (FixUtils.isSet(deliverToCompID)) FixUtils.putFixTag( out, FixTags.DELIVERTOCOMPID_INT, deliverToCompID, 0, Utils.lastIndexTrim(deliverToCompID, (byte)0) );
		if (FixUtils.isSet(secureDataLen)) FixUtils.putFixTag( out, FixTags.SECUREDATALEN_INT, secureDataLen);
		if (FixUtils.isSet(secureData)) FixUtils.putFixTag( out, FixTags.SECUREDATA_INT, secureData, 0, Utils.lastIndexTrim(secureData, (byte)0) );
		FixUtils.putFixTag( out, FixTags.MSGSEQNUM_INT, msgSeqNum);
		if (FixUtils.isSet(senderSubID)) FixUtils.putFixTag( out, FixTags.SENDERSUBID_INT, senderSubID, 0, Utils.lastIndexTrim(senderSubID, (byte)0) );
		if (FixUtils.isSet(senderLocationID)) FixUtils.putFixTag( out, FixTags.SENDERLOCATIONID_INT, senderLocationID, 0, Utils.lastIndexTrim(senderLocationID, (byte)0) );
		if (FixUtils.isSet(targetSubID)) FixUtils.putFixTag( out, FixTags.TARGETSUBID_INT, targetSubID, 0, Utils.lastIndexTrim(targetSubID, (byte)0) );
		if (FixUtils.isSet(targetLocationID)) FixUtils.putFixTag( out, FixTags.TARGETLOCATIONID_INT, targetLocationID, 0, Utils.lastIndexTrim(targetLocationID, (byte)0) );
		if (FixUtils.isSet(onBehalfOfSubID)) FixUtils.putFixTag( out, FixTags.ONBEHALFOFSUBID_INT, onBehalfOfSubID, 0, Utils.lastIndexTrim(onBehalfOfSubID, (byte)0) );
		if (FixUtils.isSet(onBehalfOfLocationID)) FixUtils.putFixTag( out, FixTags.ONBEHALFOFLOCATIONID_INT, onBehalfOfLocationID, 0, Utils.lastIndexTrim(onBehalfOfLocationID, (byte)0) );
		if (FixUtils.isSet(deliverToSubID)) FixUtils.putFixTag( out, FixTags.DELIVERTOSUBID_INT, deliverToSubID, 0, Utils.lastIndexTrim(deliverToSubID, (byte)0) );
		if (FixUtils.isSet(deliverToLocationID)) FixUtils.putFixTag( out, FixTags.DELIVERTOLOCATIONID_INT, deliverToLocationID, 0, Utils.lastIndexTrim(deliverToLocationID, (byte)0) );
		if (FixUtils.isSet(possDupFlag)) FixUtils.putFixTag( out, FixTags.POSSDUPFLAG_INT, possDupFlag?(byte)'Y':(byte)'N' );
		if (FixUtils.isSet(possResend)) FixUtils.putFixTag( out, FixTags.POSSRESEND_INT, possResend?(byte)'Y':(byte)'N' );
		FixUtils.putFixTag( out, FixTags.SENDINGTIME_INT, sendingTime);
		if (FixUtils.isSet(origSendingTime)) FixUtils.putFixTag( out, FixTags.ORIGSENDINGTIME_INT, origSendingTime);
		if (FixUtils.isSet(xmlDataLen)) FixUtils.putFixTag( out, FixTags.XMLDATALEN_INT, xmlDataLen);
		if (FixUtils.isSet(xmlData)) FixUtils.putFixTag( out, FixTags.XMLDATA_INT, xmlData, 0, Utils.lastIndexTrim(xmlData, (byte)0) );
		if (FixUtils.isSet(messageEncoding)) FixUtils.putFixTag( out, FixTags.MESSAGEENCODING_INT, messageEncoding, 0, Utils.lastIndexTrim(messageEncoding, (byte)0) );
		if (FixUtils.isSet(lastMsgSeqNumProcessed)) FixUtils.putFixTag( out, FixTags.LASTMSGSEQNUMPROCESSED_INT, lastMsgSeqNumProcessed);

		if (FixUtils.isSet(bidID)) FixUtils.putFixTag( out, FixTags.BIDID_INT, bidID, 0, Utils.lastIndexTrim(bidID, (byte)0) );
		FixUtils.putFixTag( out, FixTags.CLIENTBIDID_INT, clientBidID, 0, Utils.lastIndexTrim(clientBidID, (byte)0) );
		FixUtils.putFixTag( out, FixTags.BIDREQUESTTRANSTYPE_INT, bidRequestTransType );
		if (FixUtils.isSet(listName)) FixUtils.putFixTag( out, FixTags.LISTNAME_INT, listName, 0, Utils.lastIndexTrim(listName, (byte)0) );
		FixUtils.putFixTag( out, FixTags.TOTNORELATEDSYM_INT, totNoRelatedSym);
		FixUtils.putFixTag( out, FixTags.BIDTYPE_INT, bidType);
		if (FixUtils.isSet(numTickets)) FixUtils.putFixTag( out, FixTags.NUMTICKETS_INT, numTickets);
		if (FixUtils.isSet(currency)) FixUtils.putFixTag( out, FixTags.CURRENCY_INT, currency, 0, Utils.lastIndexTrim(currency, (byte)0) );
		if (FixUtils.isSet(sideValue1)) FixUtils.putFixTag( out, FixTags.SIDEVALUE1_INT, sideValue1);
		if (FixUtils.isSet(sideValue2)) FixUtils.putFixTag( out, FixTags.SIDEVALUE2_INT, sideValue2);
		if (FixUtils.isSet(liquidityIndType)) FixUtils.putFixTag( out, FixTags.LIQUIDITYINDTYPE_INT, liquidityIndType);
		if (FixUtils.isSet(wtAverageLiquidity)) FixUtils.putFixFloatTag( out, FixTags.WTAVERAGELIQUIDITY_INT, wtAverageLiquidity);
		if (FixUtils.isSet(exchangeForPhysical)) FixUtils.putFixTag( out, FixTags.EXCHANGEFORPHYSICAL_INT, exchangeForPhysical?(byte)'Y':(byte)'N' );
		if (FixUtils.isSet(outMainCntryUIndex)) FixUtils.putFixTag( out, FixTags.OUTMAINCNTRYUINDEX_INT, outMainCntryUIndex);
		if (FixUtils.isSet(crossPercent)) FixUtils.putFixFloatTag( out, FixTags.CROSSPERCENT_INT, crossPercent);
		if (FixUtils.isSet(progRptReqs)) FixUtils.putFixTag( out, FixTags.PROGRPTREQS_INT, progRptReqs);
		if (FixUtils.isSet(progPeriodInterval)) FixUtils.putFixTag( out, FixTags.PROGPERIODINTERVAL_INT, progPeriodInterval);
		if (FixUtils.isSet(incTaxInd)) FixUtils.putFixTag( out, FixTags.INCTAXIND_INT, incTaxInd);
		if (FixUtils.isSet(forexReq)) FixUtils.putFixTag( out, FixTags.FOREXREQ_INT, forexReq?(byte)'Y':(byte)'N' );
		if (FixUtils.isSet(numBidders)) FixUtils.putFixTag( out, FixTags.NUMBIDDERS_INT, numBidders);
		if (FixUtils.isSet(tradeDate)) FixUtils.putFixTag( out, FixTags.TRADEDATE_INT, tradeDate);
		FixUtils.putFixTag( out, FixTags.BIDTRADETYPE_INT, bidTradeType );
		FixUtils.putFixTag( out, FixTags.BASISPXTYPE_INT, basisPxType );
		if (FixUtils.isSet(strikeTime)) FixUtils.putFixTag( out, FixTags.STRIKETIME_INT, strikeTime);
		if (FixUtils.isSet(text)) FixUtils.putFixTag( out, FixTags.TEXT_INT, text, 0, Utils.lastIndexTrim(text, (byte)0) );
		if (FixUtils.isSet(encodedTextLen)) FixUtils.putFixTag( out, FixTags.ENCODEDTEXTLEN_INT, encodedTextLen);
		if (FixUtils.isSet(encodedText)) FixUtils.putFixTag( out, FixTags.ENCODEDTEXT_INT, encodedText, 0, Utils.lastIndexTrim(encodedText, (byte)0) );
		// the checksum at the end

		int checkSumStart = out.position();
		out.position( msgLengthValueStart );
		bodyLength = checkSumStart - msgTypeStart;
		Utils.longToNumeric( out, bodyLength, Utils.digits(FixConstants.MAX_MESSAGE_SIZE) );

		checkSum = FixUtils.computeChecksum( out, msgStart, checkSumStart );
		out.position( checkSumStart );
		FixUtils.putFixTag( out, FixTags.CHECKSUM_INT, checkSum );

		out.flip();

	}
	@Override		
	public void printBuffer(ByteBuffer out) {

		out.put(buf);

		out.flip();

	}

	/**
	 * If you use toString for any other purpose than administrative printout.
	 * You will end up in nifelheim!
	**/
	@Override
	public String toString() {
		char sep = '\n';
		if (Boolean.getBoolean("fix.useOneLiner")) sep = SOH;

		String s = "BeginString(8)=" + new String(BEGINSTRING_VALUE) + sep;
		s += "BodyLength(9)=" + bodyLength + sep;
		s += "MsgType(35)=" + new String(MsgTypes.BIDREQUEST) + sep;

		try {
			// print all fields including the header

			if (FixUtils.isSet(applVerID)) s += "ApplVerID(1128)=" + new String(applVerID) + sep;
			if (FixUtils.isSet(cstmApplVerID)) s += "CstmApplVerID(1129)=" + new String(cstmApplVerID) + sep;
			if (FixUtils.isSet(applExtID)) s += "ApplExtID(1156)=" + String.valueOf(applExtID) + sep;
			 s += "SenderCompID(49)=" + new String(senderCompID) + sep;
			 s += "TargetCompID(56)=" + new String(targetCompID) + sep;
			if (FixUtils.isSet(onBehalfOfCompID)) s += "OnBehalfOfCompID(115)=" + new String(onBehalfOfCompID) + sep;
			if (FixUtils.isSet(deliverToCompID)) s += "DeliverToCompID(128)=" + new String(deliverToCompID) + sep;
			if (FixUtils.isSet(secureDataLen)) s += "SecureDataLen(90)=" + String.valueOf(secureDataLen) + sep;
			if (FixUtils.isSet(secureData)) s += "SecureData(91)=" + new String(secureData) + sep;
			 s += "MsgSeqNum(34)=" + String.valueOf(msgSeqNum) + sep;
			if (FixUtils.isSet(senderSubID)) s += "SenderSubID(50)=" + new String(senderSubID) + sep;
			if (FixUtils.isSet(senderLocationID)) s += "SenderLocationID(142)=" + new String(senderLocationID) + sep;
			if (FixUtils.isSet(targetSubID)) s += "TargetSubID(57)=" + new String(targetSubID) + sep;
			if (FixUtils.isSet(targetLocationID)) s += "TargetLocationID(143)=" + new String(targetLocationID) + sep;
			if (FixUtils.isSet(onBehalfOfSubID)) s += "OnBehalfOfSubID(116)=" + new String(onBehalfOfSubID) + sep;
			if (FixUtils.isSet(onBehalfOfLocationID)) s += "OnBehalfOfLocationID(144)=" + new String(onBehalfOfLocationID) + sep;
			if (FixUtils.isSet(deliverToSubID)) s += "DeliverToSubID(129)=" + new String(deliverToSubID) + sep;
			if (FixUtils.isSet(deliverToLocationID)) s += "DeliverToLocationID(145)=" + new String(deliverToLocationID) + sep;
			if (FixUtils.isSet(possDupFlag)) s += "PossDupFlag(43)=" + String.valueOf(possDupFlag) + sep;
			if (FixUtils.isSet(possResend)) s += "PossResend(97)=" + String.valueOf(possResend) + sep;
			 s += "SendingTime(52)=" + new String(sendingTime) + sep;
			if (FixUtils.isSet(origSendingTime)) s += "OrigSendingTime(122)=" + new String(origSendingTime) + sep;
			if (FixUtils.isSet(xmlDataLen)) s += "XmlDataLen(212)=" + String.valueOf(xmlDataLen) + sep;
			if (FixUtils.isSet(xmlData)) s += "XmlData(213)=" + new String(xmlData) + sep;
			if (FixUtils.isSet(messageEncoding)) s += "MessageEncoding(347)=" + new String(messageEncoding) + sep;
			if (FixUtils.isSet(lastMsgSeqNumProcessed)) s += "LastMsgSeqNumProcessed(369)=" + String.valueOf(lastMsgSeqNumProcessed) + sep;

			if (FixUtils.isSet(bidID)) s += "BidID(390)=" + new String(bidID) + sep;
			 s += "ClientBidID(391)=" + new String(clientBidID) + sep;
			 s += "BidRequestTransType(374)=" + String.valueOf(bidRequestTransType) + sep;
			if (FixUtils.isSet(listName)) s += "ListName(392)=" + new String(listName) + sep;
			 s += "TotNoRelatedSym(393)=" + String.valueOf(totNoRelatedSym) + sep;
			 s += "BidType(394)=" + String.valueOf(bidType) + sep;
			if (FixUtils.isSet(numTickets)) s += "NumTickets(395)=" + String.valueOf(numTickets) + sep;
			if (FixUtils.isSet(currency)) s += "Currency(15)=" + new String(currency) + sep;
			if (FixUtils.isSet(sideValue1)) s += "SideValue1(396)=" + String.valueOf(sideValue1) + sep;
			if (FixUtils.isSet(sideValue2)) s += "SideValue2(397)=" + String.valueOf(sideValue2) + sep;
			if (FixUtils.isSet(liquidityIndType)) s += "LiquidityIndType(409)=" + String.valueOf(liquidityIndType) + sep;
			if (FixUtils.isSet(wtAverageLiquidity)) s += "WtAverageLiquidity(410)=" + String.valueOf(wtAverageLiquidity) + sep;
			if (FixUtils.isSet(exchangeForPhysical)) s += "ExchangeForPhysical(411)=" + String.valueOf(exchangeForPhysical) + sep;
			if (FixUtils.isSet(outMainCntryUIndex)) s += "OutMainCntryUIndex(412)=" + String.valueOf(outMainCntryUIndex) + sep;
			if (FixUtils.isSet(crossPercent)) s += "CrossPercent(413)=" + String.valueOf(crossPercent) + sep;
			if (FixUtils.isSet(progRptReqs)) s += "ProgRptReqs(414)=" + String.valueOf(progRptReqs) + sep;
			if (FixUtils.isSet(progPeriodInterval)) s += "ProgPeriodInterval(415)=" + String.valueOf(progPeriodInterval) + sep;
			if (FixUtils.isSet(incTaxInd)) s += "IncTaxInd(416)=" + String.valueOf(incTaxInd) + sep;
			if (FixUtils.isSet(forexReq)) s += "ForexReq(121)=" + String.valueOf(forexReq) + sep;
			if (FixUtils.isSet(numBidders)) s += "NumBidders(417)=" + String.valueOf(numBidders) + sep;
			if (FixUtils.isSet(tradeDate)) s += "TradeDate(75)=" + new String(tradeDate) + sep;
			 s += "BidTradeType(418)=" + String.valueOf(bidTradeType) + sep;
			 s += "BasisPxType(419)=" + String.valueOf(basisPxType) + sep;
			if (FixUtils.isSet(strikeTime)) s += "StrikeTime(443)=" + new String(strikeTime) + sep;
			if (FixUtils.isSet(text)) s += "Text(58)=" + new String(text) + sep;
			if (FixUtils.isSet(encodedTextLen)) s += "EncodedTextLen(354)=" + String.valueOf(encodedTextLen) + sep;
			if (FixUtils.isSet(encodedText)) s += "EncodedText(355)=" + new String(encodedText) + sep;

			s += "checkSum(10)=" + String.valueOf(checkSum) + sep;

		} catch(Exception e) {  };

		return s;
	}

	@Override
	public boolean equals(Object o) {
		if (! ( o instanceof FixBidRequest)) return false;

			FixBidRequest msg = (FixBidRequest) o;

		if ( ! super.equals(msg) ) return false;

		if (!Utils.equals( bidID, msg.bidID)) return false;

		if (!Utils.equals( clientBidID, msg.clientBidID)) return false;

		if (!( bidRequestTransType==msg.bidRequestTransType)) return false;

		if (!Utils.equals( listName, msg.listName)) return false;

		if (!( totNoRelatedSym==msg.totNoRelatedSym)) return false;

		if (!( bidType==msg.bidType)) return false;

		if (!( numTickets==msg.numTickets)) return false;

		if (!Utils.equals( currency, msg.currency)) return false;

		if (!( sideValue1==msg.sideValue1)) return false;

		if (!( sideValue2==msg.sideValue2)) return false;

		if (!( liquidityIndType==msg.liquidityIndType)) return false;

		if (!( wtAverageLiquidity==msg.wtAverageLiquidity)) return false;

		if (!( exchangeForPhysical==msg.exchangeForPhysical)) return false;

		if (!( outMainCntryUIndex==msg.outMainCntryUIndex)) return false;

		if (!( crossPercent==msg.crossPercent)) return false;

		if (!( progRptReqs==msg.progRptReqs)) return false;

		if (!( progPeriodInterval==msg.progPeriodInterval)) return false;

		if (!( incTaxInd==msg.incTaxInd)) return false;

		if (!( forexReq==msg.forexReq)) return false;

		if (!( numBidders==msg.numBidders)) return false;

		if (!( bidTradeType==msg.bidTradeType)) return false;

		if (!( basisPxType==msg.basisPxType)) return false;

		if (!Utils.equals( text, msg.text)) return false;

		if (!( encodedTextLen==msg.encodedTextLen)) return false;

		if (!Utils.equals( encodedText, msg.encodedText)) return false;

		return true;
	}
}
