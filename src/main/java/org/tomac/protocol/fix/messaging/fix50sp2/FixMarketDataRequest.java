package org.tomac.protocol.fix.messaging.fix50sp2;

// DO NOT EDIT!!!
// This file is generated by FixMessageGenerator.
// If you need additional functionality, put it in a helper class
// that does not live in this folder!!!  Any java file in this folder 
// will be deleted upon the next run of the FixMessageGenerator!

import java.nio.ByteBuffer;

import org.tomac.protocol.fix.FixUtils;
import org.tomac.protocol.fix.FixSessionException;
import org.tomac.protocol.fix.FixGarbledException;
import org.tomac.utils.Utils;
import org.tomac.protocol.fix.FixConstants;


import org.tomac.protocol.fix.messaging.fix50sp2.component.FixHopGrp;
import org.tomac.protocol.fix.messaging.fix50sp2.component.FixParties;
import org.tomac.protocol.fix.messaging.fix50sp2.component.FixMDReqGrp;
import org.tomac.protocol.fix.messaging.fix50sp2.component.FixInstrmtMDReqGrp;
import org.tomac.protocol.fix.messaging.fix50sp2.component.FixTrdgSesGrp;

public class FixMarketDataRequest extends FixMessage
{

	public byte[] mDReqID;
	public byte subscriptionRequestType = (byte)' ';
	public FixParties parties;
	public long marketDepth = 0;
	public long mDUpdateType = 0;
	public boolean aggregatedBook = false;
	public byte[] openCloseSettlFlag;
	public byte[] scope;
	public boolean mDImplicitDelete = false;
	public FixMDReqGrp mDReqGrp;
	public FixInstrmtMDReqGrp instrmtMDReqGrp;
	public FixTrdgSesGrp trdgSesGrp;
	public long applQueueAction = 0;
	public long applQueueMax = 0;
	public long mDQuoteType = 0;

	public FixMarketDataRequest() {
		super();

		mDReqID = new byte[FixUtils.FIX_MAX_STRING_LENGTH];
		parties = new FixParties();
		openCloseSettlFlag = new byte[FixUtils.FIX_MAX_STRING_LENGTH];
		scope = new byte[FixUtils.FIX_MAX_STRING_LENGTH];
		mDReqGrp = new FixMDReqGrp();
		instrmtMDReqGrp = new FixInstrmtMDReqGrp();
		trdgSesGrp = new FixTrdgSesGrp();
		this.clear();

		msgType = MsgTypes.MARKETDATAREQUEST_INT;

	}

	@Override
	public void clear()
	{

		// clear out all the fields that aren't msgType

		Utils.fill( mDReqID, (byte)0 );
		subscriptionRequestType = Byte.MAX_VALUE;		
		marketDepth = Long.MAX_VALUE;		
		mDUpdateType = Long.MAX_VALUE;		
		aggregatedBook = false;		
		Utils.fill( openCloseSettlFlag, (byte)0 );
		Utils.fill( scope, (byte)0 );
		mDImplicitDelete = false;		
		applQueueAction = Long.MAX_VALUE;		
		applQueueMax = Long.MAX_VALUE;		
		mDQuoteType = Long.MAX_VALUE;		
		parties.clear();
		mDReqGrp.clear();
		instrmtMDReqGrp.clear();
		trdgSesGrp.clear();
	}

	@Override
	public void getAll() throws FixSessionException, FixGarbledException
	{

		int startTagPosition = buf.position();

		super.getAll();

		// assumption message is full otherwise decode would return null
		// so negative id means that we are at the end of the message
		int id;
		int lastTagPosition = buf.position();
		while ( ( id = FixUtils.getTagId( buf ) ) > 0 )
		{
			ByteBuffer value;

			value = buf;

			switch( id ) {

			case FixTags.MDREQID_INT:
				mDReqID = FixUtils.getTagStringValue(value, mDReqID);
				break;

			case FixTags.SUBSCRIPTIONREQUESTTYPE_INT:
				subscriptionRequestType = FixUtils.getTagCharValue( value );
				if (!SubscriptionRequestType.isValid(subscriptionRequestType) ) throw new FixSessionException(buf, "Invalid enumerated value(" + subscriptionRequestType + ") for tag: " + id );
				break;

			case FixTags.NOPARTYIDS_INT:
				parties.noPartyIDs = FixUtils.getTagIntValue( value );
				parties.getAll(parties.noPartyIDs, value );
				break;

			case FixTags.MARKETDEPTH_INT:
				marketDepth = FixUtils.getTagIntValue( value );
				break;

			case FixTags.MDUPDATETYPE_INT:
				mDUpdateType = FixUtils.getTagIntValue( value );
				if (!MDUpdateType.isValid(mDUpdateType) ) throw new FixSessionException(buf, "Invalid enumerated value(" + mDUpdateType + ") for tag: " + id );
				break;

			case FixTags.AGGREGATEDBOOK_INT:
				aggregatedBook = FixUtils.getTagBooleanValue( value );
				if (!AggregatedBook.isValid(aggregatedBook) ) throw new FixSessionException(buf, "Invalid enumerated value(" + aggregatedBook + ") for tag: " + id );
				break;

			case FixTags.OPENCLOSESETTLFLAG_INT:
				openCloseSettlFlag = FixUtils.getTagStringValue(value, openCloseSettlFlag);
				if (!OpenCloseSettlFlag.isValid(openCloseSettlFlag) ) throw new FixSessionException(buf, "Invalid enumerated value(" + openCloseSettlFlag + ") for tag: " + id );
				break;

			case FixTags.SCOPE_INT:
				scope = FixUtils.getTagStringValue(value, scope);
				if (!Scope.isValid(scope) ) throw new FixSessionException(buf, "Invalid enumerated value(" + scope + ") for tag: " + id );
				break;

			case FixTags.MDIMPLICITDELETE_INT:
				mDImplicitDelete = FixUtils.getTagBooleanValue( value );
				if (!MDImplicitDelete.isValid(mDImplicitDelete) ) throw new FixSessionException(buf, "Invalid enumerated value(" + mDImplicitDelete + ") for tag: " + id );
				break;

			case FixTags.NOMDENTRYTYPES_INT:
				mDReqGrp.noMDEntryTypes = FixUtils.getTagIntValue( value );
				mDReqGrp.getAll(mDReqGrp.noMDEntryTypes, value );
				break;

			case FixTags.NORELATEDSYM_INT:
				instrmtMDReqGrp.noRelatedSym = FixUtils.getTagIntValue( value );
				instrmtMDReqGrp.getAll(instrmtMDReqGrp.noRelatedSym, value );
				break;

			case FixTags.NOTRADINGSESSIONS_INT:
				trdgSesGrp.noTradingSessions = FixUtils.getTagIntValue( value );
				trdgSesGrp.getAll(trdgSesGrp.noTradingSessions, value );
				break;

			case FixTags.APPLQUEUEACTION_INT:
				applQueueAction = FixUtils.getTagIntValue( value );
				if (!ApplQueueAction.isValid(applQueueAction) ) throw new FixSessionException(buf, "Invalid enumerated value(" + applQueueAction + ") for tag: " + id );
				break;

			case FixTags.APPLQUEUEMAX_INT:
				applQueueMax = FixUtils.getTagIntValue( value );
				break;

			case FixTags.MDQUOTETYPE_INT:
				mDQuoteType = FixUtils.getTagIntValue( value );
				if (!MDQuoteType.isValid(mDQuoteType) ) throw new FixSessionException(buf, "Invalid enumerated value(" + mDQuoteType + ") for tag: " + id );
				break;

			// for a message always get the checksum
			case FixTags.CHECKSUM_INT:
				checkSum = FixUtils.getTagIntValue( value );

				id = checkRequiredTags();
				if (id > 0) throw new FixSessionException(buf, "Required tag missing: " + id );

				return;

			default:
				throw new FixSessionException(buf, "Unknown tag: " + id );

			}

			lastTagPosition = buf.position();

		}

		buf.position(startTagPosition);

	}

	private int checkRequiredTags() {
		int tag = -1;

		if (! FixUtils.isSet(senderCompID) ) return FixTags.SENDERCOMPID_INT;
		if (! FixUtils.isSet(targetCompID) ) return FixTags.TARGETCOMPID_INT;
		if (! FixUtils.isSet(msgSeqNum) ) return FixTags.MSGSEQNUM_INT;
		if (! FixUtils.isSet(sendingTime) ) return FixTags.SENDINGTIME_INT;
		if (! FixUtils.isSet(mDReqID) ) return FixTags.MDREQID_INT;
		if (! FixUtils.isSet(subscriptionRequestType) ) return FixTags.SUBSCRIPTIONREQUESTTYPE_INT;
		if (! FixUtils.isSet(marketDepth) ) return FixTags.MARKETDEPTH_INT;
		if (! mDReqGrp.isSet() ) return FixTags.NOMDENTRYTYPES_INT;
		if (! instrmtMDReqGrp.isSet() ) return FixTags.NORELATEDSYM_INT;
		if (! FixUtils.isSet(checkSum) ) return FixTags.CHECKSUM_INT;
		return tag;

	}
	@Override
	public void encode( ByteBuffer out )
	{
		// Encode message. Set msgSeqNum and sendingTime and optional resend flags, before encoding. 

		int msgStart = out.position();

		out.put( BEGINSTRING_VALUE_WITH_TAG );

		int msgLengthValueStart = out.position() + 2 /* 9= */;

		// placeholder
		FixUtils.putFixTag(out, FixTags.BODYLENGTH_INT, FixConstants.MAX_MESSAGE_SIZE );

		int msgTypeStart = out.position();

		FixUtils.putFixTag( out, FixTags.MSGTYPE_INT, MsgTypes.MARKETDATAREQUEST);

		// encode all fields including the header

		if (FixUtils.isSet(applVerID)) FixUtils.putFixTag( out, FixTags.APPLVERID_INT, applVerID, 0, Utils.lastIndexTrim(applVerID, (byte)0) );
		if (FixUtils.isSet(cstmApplVerID)) FixUtils.putFixTag( out, FixTags.CSTMAPPLVERID_INT, cstmApplVerID, 0, Utils.lastIndexTrim(cstmApplVerID, (byte)0) );
		if (FixUtils.isSet(applExtID)) FixUtils.putFixTag( out, FixTags.APPLEXTID_INT, applExtID);
		FixUtils.putFixTag( out, FixTags.SENDERCOMPID_INT, senderCompID, 0, Utils.lastIndexTrim(senderCompID, (byte)0) );
		FixUtils.putFixTag( out, FixTags.TARGETCOMPID_INT, targetCompID, 0, Utils.lastIndexTrim(targetCompID, (byte)0) );
		if (FixUtils.isSet(onBehalfOfCompID)) FixUtils.putFixTag( out, FixTags.ONBEHALFOFCOMPID_INT, onBehalfOfCompID, 0, Utils.lastIndexTrim(onBehalfOfCompID, (byte)0) );
		if (FixUtils.isSet(deliverToCompID)) FixUtils.putFixTag( out, FixTags.DELIVERTOCOMPID_INT, deliverToCompID, 0, Utils.lastIndexTrim(deliverToCompID, (byte)0) );
		if (FixUtils.isSet(secureDataLen)) FixUtils.putFixTag( out, FixTags.SECUREDATALEN_INT, secureDataLen);
		if (FixUtils.isSet(secureData)) FixUtils.putFixTag( out, FixTags.SECUREDATA_INT, secureData, 0, Utils.lastIndexTrim(secureData, (byte)0) );
		FixUtils.putFixTag( out, FixTags.MSGSEQNUM_INT, msgSeqNum);
		if (FixUtils.isSet(senderSubID)) FixUtils.putFixTag( out, FixTags.SENDERSUBID_INT, senderSubID, 0, Utils.lastIndexTrim(senderSubID, (byte)0) );
		if (FixUtils.isSet(senderLocationID)) FixUtils.putFixTag( out, FixTags.SENDERLOCATIONID_INT, senderLocationID, 0, Utils.lastIndexTrim(senderLocationID, (byte)0) );
		if (FixUtils.isSet(targetSubID)) FixUtils.putFixTag( out, FixTags.TARGETSUBID_INT, targetSubID, 0, Utils.lastIndexTrim(targetSubID, (byte)0) );
		if (FixUtils.isSet(targetLocationID)) FixUtils.putFixTag( out, FixTags.TARGETLOCATIONID_INT, targetLocationID, 0, Utils.lastIndexTrim(targetLocationID, (byte)0) );
		if (FixUtils.isSet(onBehalfOfSubID)) FixUtils.putFixTag( out, FixTags.ONBEHALFOFSUBID_INT, onBehalfOfSubID, 0, Utils.lastIndexTrim(onBehalfOfSubID, (byte)0) );
		if (FixUtils.isSet(onBehalfOfLocationID)) FixUtils.putFixTag( out, FixTags.ONBEHALFOFLOCATIONID_INT, onBehalfOfLocationID, 0, Utils.lastIndexTrim(onBehalfOfLocationID, (byte)0) );
		if (FixUtils.isSet(deliverToSubID)) FixUtils.putFixTag( out, FixTags.DELIVERTOSUBID_INT, deliverToSubID, 0, Utils.lastIndexTrim(deliverToSubID, (byte)0) );
		if (FixUtils.isSet(deliverToLocationID)) FixUtils.putFixTag( out, FixTags.DELIVERTOLOCATIONID_INT, deliverToLocationID, 0, Utils.lastIndexTrim(deliverToLocationID, (byte)0) );
		if (FixUtils.isSet(possDupFlag)) FixUtils.putFixTag( out, FixTags.POSSDUPFLAG_INT, possDupFlag?(byte)'Y':(byte)'N' );
		if (FixUtils.isSet(possResend)) FixUtils.putFixTag( out, FixTags.POSSRESEND_INT, possResend?(byte)'Y':(byte)'N' );
		FixUtils.putFixTag( out, FixTags.SENDINGTIME_INT, sendingTime);
		if (FixUtils.isSet(origSendingTime)) FixUtils.putFixTag( out, FixTags.ORIGSENDINGTIME_INT, origSendingTime);
		if (FixUtils.isSet(xmlDataLen)) FixUtils.putFixTag( out, FixTags.XMLDATALEN_INT, xmlDataLen);
		if (FixUtils.isSet(xmlData)) FixUtils.putFixTag( out, FixTags.XMLDATA_INT, xmlData, 0, Utils.lastIndexTrim(xmlData, (byte)0) );
		if (FixUtils.isSet(messageEncoding)) FixUtils.putFixTag( out, FixTags.MESSAGEENCODING_INT, messageEncoding, 0, Utils.lastIndexTrim(messageEncoding, (byte)0) );
		if (FixUtils.isSet(lastMsgSeqNumProcessed)) FixUtils.putFixTag( out, FixTags.LASTMSGSEQNUMPROCESSED_INT, lastMsgSeqNumProcessed);
		if ( FixUtils.isSet(hopGrp.noHops) )hopGrp.encode( out );

		FixUtils.putFixTag( out, FixTags.MDREQID_INT, mDReqID, 0, Utils.lastIndexTrim(mDReqID, (byte)0) );
		FixUtils.putFixTag( out, FixTags.SUBSCRIPTIONREQUESTTYPE_INT, subscriptionRequestType );
		if (FixUtils.isSet(parties.noPartyIDs)) parties.encode( out );
		FixUtils.putFixTag( out, FixTags.MARKETDEPTH_INT, marketDepth);
		if (FixUtils.isSet(mDUpdateType)) FixUtils.putFixTag( out, FixTags.MDUPDATETYPE_INT, mDUpdateType);
		if (FixUtils.isSet(aggregatedBook)) FixUtils.putFixTag( out, FixTags.AGGREGATEDBOOK_INT, aggregatedBook?(byte)'Y':(byte)'N' );
		if (FixUtils.isSet(openCloseSettlFlag)) FixUtils.putFixTag( out, FixTags.OPENCLOSESETTLFLAG_INT, openCloseSettlFlag, 0, Utils.lastIndexTrim(openCloseSettlFlag, (byte)0) );
		if (FixUtils.isSet(scope)) FixUtils.putFixTag( out, FixTags.SCOPE_INT, scope, 0, Utils.lastIndexTrim(scope, (byte)0) );
		if (FixUtils.isSet(mDImplicitDelete)) FixUtils.putFixTag( out, FixTags.MDIMPLICITDELETE_INT, mDImplicitDelete?(byte)'Y':(byte)'N' );
		mDReqGrp.encode( out );
		instrmtMDReqGrp.encode( out );
		if (FixUtils.isSet(trdgSesGrp.noTradingSessions)) trdgSesGrp.encode( out );
		if (FixUtils.isSet(applQueueAction)) FixUtils.putFixTag( out, FixTags.APPLQUEUEACTION_INT, applQueueAction);
		if (FixUtils.isSet(applQueueMax)) FixUtils.putFixTag( out, FixTags.APPLQUEUEMAX_INT, applQueueMax);
		if (FixUtils.isSet(mDQuoteType)) FixUtils.putFixTag( out, FixTags.MDQUOTETYPE_INT, mDQuoteType);
		// the checksum at the end

		int checkSumStart = out.position();
		out.position( msgLengthValueStart );
		bodyLength = checkSumStart - msgTypeStart;
		Utils.longToNumeric( out, bodyLength, Utils.digits(FixConstants.MAX_MESSAGE_SIZE) );

		checkSum = FixUtils.computeChecksum( out, msgStart, checkSumStart );
		out.position( checkSumStart );
		FixUtils.putFixTag( out, FixTags.CHECKSUM_INT, checkSum );

		out.flip();

	}
	@Override		
	public void printBuffer(ByteBuffer out) {

		out.put(buf);

		out.flip();

	}

	/**
	 * If you use toString for any other purpose than administrative printout.
	 * You will end up in nifelheim!
	**/
	@Override
	public String toString() {
		char sep = '\n';
		if (Boolean.getBoolean("fix.useOneLiner")) sep = SOH;

		String s = "BeginString(8)=" + new String(BEGINSTRING_VALUE) + sep;
		s += "BodyLength(9)=" + bodyLength + sep;
		s += "MsgType(35)=" + new String(MsgTypes.MARKETDATAREQUEST) + sep;

		try {
			// print all fields including the header

			if (FixUtils.isSet(applVerID)) s += "ApplVerID(1128)=" + new String(applVerID) + sep;
			if (FixUtils.isSet(cstmApplVerID)) s += "CstmApplVerID(1129)=" + new String(cstmApplVerID) + sep;
			if (FixUtils.isSet(applExtID)) s += "ApplExtID(1156)=" + String.valueOf(applExtID) + sep;
			 s += "SenderCompID(49)=" + new String(senderCompID) + sep;
			 s += "TargetCompID(56)=" + new String(targetCompID) + sep;
			if (FixUtils.isSet(onBehalfOfCompID)) s += "OnBehalfOfCompID(115)=" + new String(onBehalfOfCompID) + sep;
			if (FixUtils.isSet(deliverToCompID)) s += "DeliverToCompID(128)=" + new String(deliverToCompID) + sep;
			if (FixUtils.isSet(secureDataLen)) s += "SecureDataLen(90)=" + String.valueOf(secureDataLen) + sep;
			if (FixUtils.isSet(secureData)) s += "SecureData(91)=" + new String(secureData) + sep;
			 s += "MsgSeqNum(34)=" + String.valueOf(msgSeqNum) + sep;
			if (FixUtils.isSet(senderSubID)) s += "SenderSubID(50)=" + new String(senderSubID) + sep;
			if (FixUtils.isSet(senderLocationID)) s += "SenderLocationID(142)=" + new String(senderLocationID) + sep;
			if (FixUtils.isSet(targetSubID)) s += "TargetSubID(57)=" + new String(targetSubID) + sep;
			if (FixUtils.isSet(targetLocationID)) s += "TargetLocationID(143)=" + new String(targetLocationID) + sep;
			if (FixUtils.isSet(onBehalfOfSubID)) s += "OnBehalfOfSubID(116)=" + new String(onBehalfOfSubID) + sep;
			if (FixUtils.isSet(onBehalfOfLocationID)) s += "OnBehalfOfLocationID(144)=" + new String(onBehalfOfLocationID) + sep;
			if (FixUtils.isSet(deliverToSubID)) s += "DeliverToSubID(129)=" + new String(deliverToSubID) + sep;
			if (FixUtils.isSet(deliverToLocationID)) s += "DeliverToLocationID(145)=" + new String(deliverToLocationID) + sep;
			if (FixUtils.isSet(possDupFlag)) s += "PossDupFlag(43)=" + String.valueOf(possDupFlag) + sep;
			if (FixUtils.isSet(possResend)) s += "PossResend(97)=" + String.valueOf(possResend) + sep;
			 s += "SendingTime(52)=" + new String(sendingTime) + sep;
			if (FixUtils.isSet(origSendingTime)) s += "OrigSendingTime(122)=" + new String(origSendingTime) + sep;
			if (FixUtils.isSet(xmlDataLen)) s += "XmlDataLen(212)=" + String.valueOf(xmlDataLen) + sep;
			if (FixUtils.isSet(xmlData)) s += "XmlData(213)=" + new String(xmlData) + sep;
			if (FixUtils.isSet(messageEncoding)) s += "MessageEncoding(347)=" + new String(messageEncoding) + sep;
			if (FixUtils.isSet(lastMsgSeqNumProcessed)) s += "LastMsgSeqNumProcessed(369)=" + String.valueOf(lastMsgSeqNumProcessed) + sep;
			if (FixUtils.isSet(hopGrp.noHops)) s += hopGrp.toString();

			 s += "MDReqID(262)=" + new String(mDReqID) + sep;
			 s += "SubscriptionRequestType(263)=" + String.valueOf(subscriptionRequestType) + sep;
			if (FixUtils.isSet(parties.noPartyIDs)) s += parties.toString();
			 s += "MarketDepth(264)=" + String.valueOf(marketDepth) + sep;
			if (FixUtils.isSet(mDUpdateType)) s += "MDUpdateType(265)=" + String.valueOf(mDUpdateType) + sep;
			if (FixUtils.isSet(aggregatedBook)) s += "AggregatedBook(266)=" + String.valueOf(aggregatedBook) + sep;
			if (FixUtils.isSet(openCloseSettlFlag)) s += "OpenCloseSettlFlag(286)=" + new String(openCloseSettlFlag) + sep;
			if (FixUtils.isSet(scope)) s += "Scope(546)=" + new String(scope) + sep;
			if (FixUtils.isSet(mDImplicitDelete)) s += "MDImplicitDelete(547)=" + String.valueOf(mDImplicitDelete) + sep;
			 s += mDReqGrp.toString();
			 s += instrmtMDReqGrp.toString();
			if (FixUtils.isSet(trdgSesGrp.noTradingSessions)) s += trdgSesGrp.toString();
			if (FixUtils.isSet(applQueueAction)) s += "ApplQueueAction(815)=" + String.valueOf(applQueueAction) + sep;
			if (FixUtils.isSet(applQueueMax)) s += "ApplQueueMax(812)=" + String.valueOf(applQueueMax) + sep;
			if (FixUtils.isSet(mDQuoteType)) s += "MDQuoteType(1070)=" + String.valueOf(mDQuoteType) + sep;

			s += "checkSum(10)=" + String.valueOf(checkSum) + sep;

		} catch(Exception e) {  };

		return s;
	}

	@Override
	public boolean equals(Object o) {
		if (! ( o instanceof FixMarketDataRequest)) return false;

			FixMarketDataRequest msg = (FixMarketDataRequest) o;

		if ( ! super.equals(msg) ) return false;

		if (!Utils.equals( mDReqID, msg.mDReqID)) return false;

		if (!( subscriptionRequestType==msg.subscriptionRequestType)) return false;

		if (!parties.equals(msg.parties)) return false;

		if (!( marketDepth==msg.marketDepth)) return false;

		if (!( mDUpdateType==msg.mDUpdateType)) return false;

		if (!( aggregatedBook==msg.aggregatedBook)) return false;

		if (!Utils.equals( openCloseSettlFlag, msg.openCloseSettlFlag)) return false;

		if (!Utils.equals( scope, msg.scope)) return false;

		if (!( mDImplicitDelete==msg.mDImplicitDelete)) return false;

		if (!mDReqGrp.equals(msg.mDReqGrp)) return false;

		if (!instrmtMDReqGrp.equals(msg.instrmtMDReqGrp)) return false;

		if (!trdgSesGrp.equals(msg.trdgSesGrp)) return false;

		if (!( applQueueAction==msg.applQueueAction)) return false;

		if (!( applQueueMax==msg.applQueueMax)) return false;

		if (!( mDQuoteType==msg.mDQuoteType)) return false;

		return true;
	}
}
