package org.tomac.protocol.fix.messaging.fix50sp2.component;

// DO NOT EDIT!!!
// This file is generated by FixMessageGenerator.
// If you need additional functionality, put it in a helper class
// that does not live in this folder!!!  Any java file in this folder 
// will be deleted upon the next run of the FixMessageGenerator!

import java.nio.ByteBuffer;

import org.tomac.protocol.fix.FixUtils;
import org.tomac.protocol.fix.FixSessionException;
import org.tomac.protocol.fix.FixGarbledException;
import org.tomac.utils.Utils;
import org.tomac.protocol.fix.FixConstants;


import org.tomac.protocol.fix.messaging.fix50sp2.FixTags;
import org.tomac.protocol.fix.messaging.fix50sp2.FixMessageInfo.*;
import org.tomac.protocol.fix.messaging.fix50sp2.component.FixSecAltIDGrp;
import org.tomac.protocol.fix.messaging.fix50sp2.component.FixSecurityXML;
import org.tomac.protocol.fix.messaging.fix50sp2.component.FixEvntGrp;
import org.tomac.protocol.fix.messaging.fix50sp2.component.FixInstrumentParties;
import org.tomac.protocol.fix.messaging.fix50sp2.component.FixComplexEvents;

public class FixInstrument implements FixComponent
{

	public byte[] symbol;
	public byte[] symbolSfx;
	public byte[] securityID;
	public byte[] securityIDSource;
	public FixSecAltIDGrp secAltIDGrp;
	public long product = 0;
	public byte[] securityGroup;
	public byte[] productComplex;
	public byte[] cFICode;
	public byte[] securityType;
	public byte[] securitySubType;
	public byte[] maturityMonthYear;
	public byte[] maturityDate;
	public byte[] securityStatus;
	public byte[] settleOnOpenFlag;
	public byte instrmtAssignmentMethod = (byte)' ';
	public byte[] maturityTime;
	public byte[] couponPaymentDate;
	public byte[] restructuringType;
	public byte[] seniority;
	public long notionalPercentageOutstanding = 0;
	public long originalNotionalPercentageOutstanding = 0;
	public long attachmentPoint = 0;
	public long detachmentPoint = 0;
	public byte[] issueDate;
	public long repoCollateralSecurityType = 0;
	public long repurchaseTerm = 0;
	public long repurchaseRate = 0;
	public long factor = 0;
	public byte[] creditRating;
	public byte[] instrRegistry;
	public byte[] countryOfIssue;
	public byte[] stateOrProvinceOfIssue;
	public byte[] localeOfIssue;
	public byte[] redemptionDate;
	public long strikePrice = 0;
	public byte[] strikeCurrency;
	public long strikeMultiplier = 0;
	public long strikeValue = 0;
	public long strikePriceDeterminationMethod = 0;
	public long strikePriceBoundaryMethod = 0;
	public long strikePriceBoundaryPrecision = 0;
	public long underlyingPriceDeterminationMethod = 0;
	public byte optAttribute = (byte)' ';
	public long contractMultiplier = 0;
	public long minPriceIncrement = 0;
	public byte[] unitOfMeasure;
	public byte[] timeUnit;
	public long minPriceIncrementAmount = 0;
	public long unitOfMeasureQty = 0;
	public byte[] priceUnitOfMeasure;
	public long priceUnitOfMeasureQty = 0;
	public byte settlMethod = (byte)' ';
	public long exerciseStyle = 0;
	public long optPayoutAmount = 0;
	public byte[] priceQuoteMethod;
	public long listMethod = 0;
	public long capPrice = 0;
	public long floorPrice = 0;
	public long putOrCall = 0;
	public boolean flexibleIndicator = false;
	public boolean flexProductEligibilityIndicator = false;
	public byte[] valuationMethod;
	public long contractMultiplierUnit = 0;
	public long flowScheduleType = 0;
	public long optPayoutType = 0;
	public long couponRate = 0;
	public byte[] securityExchange;
	public long positionLimit = 0;
	public long nTPositionLimit = 0;
	public byte[] issuer;
	public long encodedIssuerLen = 0;
	public byte[] encodedIssuer;
	public byte[] securityDesc;
	public long encodedSecurityDescLen = 0;
	public byte[] encodedSecurityDesc;
	public FixSecurityXML securityXML;
	public byte[] pool;
	public byte[] contractSettlMonth;
	public long cPProgram = 0;
	public byte[] cPRegType;
	public FixEvntGrp evntGrp;
	public byte[] datedDate;
	public byte[] interestAccrualDate;
	public FixInstrumentParties instrumentParties;
	public FixComplexEvents complexEvents;

	public FixInstrument() {
		super();

		symbol = new byte[FixUtils.FIX_MAX_STRING_LENGTH];
		symbolSfx = new byte[FixUtils.FIX_MAX_STRING_LENGTH];
		securityID = new byte[FixUtils.FIX_MAX_STRING_LENGTH];
		securityIDSource = new byte[FixUtils.FIX_MAX_STRING_LENGTH];
		secAltIDGrp = new FixSecAltIDGrp();
		securityGroup = new byte[FixUtils.FIX_MAX_STRING_LENGTH];
		productComplex = new byte[FixUtils.FIX_MAX_STRING_LENGTH];
		cFICode = new byte[FixUtils.FIX_MAX_STRING_LENGTH];
		securityType = new byte[FixUtils.FIX_MAX_STRING_LENGTH];
		securitySubType = new byte[FixUtils.FIX_MAX_STRING_LENGTH];
		maturityMonthYear = new byte[FixUtils.FIX_MAX_STRING_LENGTH];
		maturityDate = new byte[FixUtils.FIX_MAX_STRING_LENGTH];
		securityStatus = new byte[FixUtils.FIX_MAX_STRING_LENGTH];
		settleOnOpenFlag = new byte[FixUtils.FIX_MAX_STRING_LENGTH];
		maturityTime = new byte[FixUtils.FIX_MAX_STRING_LENGTH];
		couponPaymentDate = new byte[FixUtils.FIX_MAX_STRING_LENGTH];
		restructuringType = new byte[FixUtils.FIX_MAX_STRING_LENGTH];
		seniority = new byte[FixUtils.FIX_MAX_STRING_LENGTH];
		issueDate = new byte[FixUtils.FIX_MAX_STRING_LENGTH];
		creditRating = new byte[FixUtils.FIX_MAX_STRING_LENGTH];
		instrRegistry = new byte[FixUtils.FIX_MAX_STRING_LENGTH];
		countryOfIssue = new byte[FixUtils.FIX_MAX_STRING_LENGTH];
		stateOrProvinceOfIssue = new byte[FixUtils.FIX_MAX_STRING_LENGTH];
		localeOfIssue = new byte[FixUtils.FIX_MAX_STRING_LENGTH];
		redemptionDate = new byte[FixUtils.FIX_MAX_STRING_LENGTH];
		strikeCurrency = new byte[FixUtils.CURRENCY_LENGTH];
		unitOfMeasure = new byte[FixUtils.FIX_MAX_STRING_LENGTH];
		timeUnit = new byte[FixUtils.FIX_MAX_STRING_LENGTH];
		priceUnitOfMeasure = new byte[FixUtils.FIX_MAX_STRING_LENGTH];
		priceQuoteMethod = new byte[FixUtils.FIX_MAX_STRING_LENGTH];
		valuationMethod = new byte[FixUtils.FIX_MAX_STRING_LENGTH];
		securityExchange = new byte[FixUtils.FIX_MAX_STRING_LENGTH];
		issuer = new byte[FixUtils.FIX_MAX_STRING_LENGTH];
		encodedIssuer = new byte[FixUtils.FIX_MAX_STRING_LENGTH];
		securityDesc = new byte[FixUtils.FIX_MAX_STRING_LENGTH];
		encodedSecurityDesc = new byte[FixUtils.FIX_MAX_STRING_LENGTH];
		securityXML = new FixSecurityXML();
		pool = new byte[FixUtils.FIX_MAX_STRING_LENGTH];
		contractSettlMonth = new byte[FixUtils.FIX_MAX_STRING_LENGTH];
		cPRegType = new byte[FixUtils.FIX_MAX_STRING_LENGTH];
		evntGrp = new FixEvntGrp();
		datedDate = new byte[FixUtils.FIX_MAX_STRING_LENGTH];
		interestAccrualDate = new byte[FixUtils.FIX_MAX_STRING_LENGTH];
		instrumentParties = new FixInstrumentParties();
		complexEvents = new FixComplexEvents();
		this.clear();

	}

	@Override
	public void clear()
	{

		// clear out all the fields that aren't msgType

		Utils.fill( symbol, (byte)0 );
		Utils.fill( symbolSfx, (byte)0 );
		Utils.fill( securityID, (byte)0 );
		Utils.fill( securityIDSource, (byte)0 );
		product = Long.MAX_VALUE;		
		Utils.fill( securityGroup, (byte)0 );
		Utils.fill( productComplex, (byte)0 );
		Utils.fill( cFICode, (byte)0 );
		Utils.fill( securityType, (byte)0 );
		Utils.fill( securitySubType, (byte)0 );
		Utils.fill( maturityMonthYear, (byte)0 );
		Utils.fill( maturityDate, (byte)0 );
		Utils.fill( securityStatus, (byte)0 );
		Utils.fill( settleOnOpenFlag, (byte)0 );
		instrmtAssignmentMethod = Byte.MAX_VALUE;		
		Utils.fill( maturityTime, (byte)0 );
		Utils.fill( couponPaymentDate, (byte)0 );
		Utils.fill( restructuringType, (byte)0 );
		Utils.fill( seniority, (byte)0 );
		notionalPercentageOutstanding = Long.MAX_VALUE;		
		originalNotionalPercentageOutstanding = Long.MAX_VALUE;		
		attachmentPoint = Long.MAX_VALUE;		
		detachmentPoint = Long.MAX_VALUE;		
		Utils.fill( issueDate, (byte)0 );
		repoCollateralSecurityType = Long.MAX_VALUE;		
		repurchaseTerm = Long.MAX_VALUE;		
		repurchaseRate = Long.MAX_VALUE;		
		factor = Long.MAX_VALUE;		
		Utils.fill( creditRating, (byte)0 );
		Utils.fill( instrRegistry, (byte)0 );
		Utils.fill( countryOfIssue, (byte)0 );
		Utils.fill( stateOrProvinceOfIssue, (byte)0 );
		Utils.fill( localeOfIssue, (byte)0 );
		Utils.fill( redemptionDate, (byte)0 );
		strikePrice = Long.MAX_VALUE;		
		Utils.fill( strikeCurrency, (byte)0 );
		strikeMultiplier = Long.MAX_VALUE;		
		strikeValue = Long.MAX_VALUE;		
		strikePriceDeterminationMethod = Long.MAX_VALUE;		
		strikePriceBoundaryMethod = Long.MAX_VALUE;		
		strikePriceBoundaryPrecision = Long.MAX_VALUE;		
		underlyingPriceDeterminationMethod = Long.MAX_VALUE;		
		optAttribute = Byte.MAX_VALUE;		
		contractMultiplier = Long.MAX_VALUE;		
		minPriceIncrement = Long.MAX_VALUE;		
		Utils.fill( unitOfMeasure, (byte)0 );
		Utils.fill( timeUnit, (byte)0 );
		minPriceIncrementAmount = Long.MAX_VALUE;		
		unitOfMeasureQty = Long.MAX_VALUE;		
		Utils.fill( priceUnitOfMeasure, (byte)0 );
		priceUnitOfMeasureQty = Long.MAX_VALUE;		
		settlMethod = Byte.MAX_VALUE;		
		exerciseStyle = Long.MAX_VALUE;		
		optPayoutAmount = Long.MAX_VALUE;		
		Utils.fill( priceQuoteMethod, (byte)0 );
		listMethod = Long.MAX_VALUE;		
		capPrice = Long.MAX_VALUE;		
		floorPrice = Long.MAX_VALUE;		
		putOrCall = Long.MAX_VALUE;		
		flexibleIndicator = false;		
		flexProductEligibilityIndicator = false;		
		Utils.fill( valuationMethod, (byte)0 );
		contractMultiplierUnit = Long.MAX_VALUE;		
		flowScheduleType = Long.MAX_VALUE;		
		optPayoutType = Long.MAX_VALUE;		
		couponRate = Long.MAX_VALUE;		
		Utils.fill( securityExchange, (byte)0 );
		positionLimit = Long.MAX_VALUE;		
		nTPositionLimit = Long.MAX_VALUE;		
		Utils.fill( issuer, (byte)0 );
		encodedIssuerLen = Long.MAX_VALUE;		
		Utils.fill( encodedIssuer, (byte)0 );
		Utils.fill( securityDesc, (byte)0 );
		encodedSecurityDescLen = Long.MAX_VALUE;		
		Utils.fill( encodedSecurityDesc, (byte)0 );
		Utils.fill( pool, (byte)0 );
		Utils.fill( contractSettlMonth, (byte)0 );
		cPProgram = Long.MAX_VALUE;		
		Utils.fill( cPRegType, (byte)0 );
		Utils.fill( datedDate, (byte)0 );
		Utils.fill( interestAccrualDate, (byte)0 );
		secAltIDGrp.clear();
		securityXML.clear();
		evntGrp.clear();
		instrumentParties.clear();
		complexEvents.clear();
	}

	public void getAll(int id, ByteBuffer buf) throws FixSessionException, FixGarbledException
	{

		int startTagPosition = buf.position();

		int lastTagPosition = buf.position();
		do {
			ByteBuffer value;

			value = buf;

			switch( id ) {

			case FixTags.SYMBOL_INT:
				symbol = FixUtils.getTagStringValue(null ,id ,value, symbol);
				break;

			case FixTags.SYMBOLSFX_INT:
				symbolSfx = FixUtils.getTagStringValue(null ,id ,value, symbolSfx);
				if (!SymbolSfx.isValid(symbolSfx) ) throw new FixSessionException(SessionRejectReason.VALUE_IS_INCORRECT_OUT_OF_RANGE_FOR_THIS_TAG, ("Invalid enumerated value(" + symbolSfx + ") for tag").getBytes(), id, new byte[0] );
				break;

			case FixTags.SECURITYID_INT:
				securityID = FixUtils.getTagStringValue(null ,id ,value, securityID);
				break;

			case FixTags.SECURITYIDSOURCE_INT:
				securityIDSource = FixUtils.getTagStringValue(null ,id ,value, securityIDSource);
				if (!SecurityIDSource.isValid(securityIDSource) ) throw new FixSessionException(SessionRejectReason.VALUE_IS_INCORRECT_OUT_OF_RANGE_FOR_THIS_TAG, ("Invalid enumerated value(" + securityIDSource + ") for tag").getBytes(), id, new byte[0] );
				break;

			case FixTags.NOSECURITYALTID_INT:
				secAltIDGrp.noSecurityAltID = FixUtils.getTagIntValue(null, FixTags.NOSECURITYALTID_INT, value );
				secAltIDGrp.getAll(secAltIDGrp.noSecurityAltID, value );
				break;

			case FixTags.PRODUCT_INT:
				product = FixUtils.getTagIntValue(null ,id ,value );
				if (!Product.isValid(product) ) throw new FixSessionException(SessionRejectReason.VALUE_IS_INCORRECT_OUT_OF_RANGE_FOR_THIS_TAG, ("Invalid enumerated value(" + product + ") for tag").getBytes(), id, new byte[0] );
				break;

			case FixTags.SECURITYGROUP_INT:
				securityGroup = FixUtils.getTagStringValue(null ,id ,value, securityGroup);
				break;

			case FixTags.PRODUCTCOMPLEX_INT:
				productComplex = FixUtils.getTagStringValue(null ,id ,value, productComplex);
				break;

			case FixTags.CFICODE_INT:
				cFICode = FixUtils.getTagStringValue(null ,id ,value, cFICode);
				break;

			case FixTags.SECURITYTYPE_INT:
				securityType = FixUtils.getTagStringValue(null ,id ,value, securityType);
				if (!SecurityType.isValid(securityType) ) throw new FixSessionException(SessionRejectReason.VALUE_IS_INCORRECT_OUT_OF_RANGE_FOR_THIS_TAG, ("Invalid enumerated value(" + securityType + ") for tag").getBytes(), id, new byte[0] );
				break;

			case FixTags.SECURITYSUBTYPE_INT:
				securitySubType = FixUtils.getTagStringValue(null ,id ,value, securitySubType);
				break;

			case FixTags.MATURITYMONTHYEAR_INT:
				maturityMonthYear = FixUtils.getTagStringValue(null ,id ,value, maturityMonthYear);
				break;

			case FixTags.MATURITYDATE_INT:
				maturityDate = FixUtils.getTagStringValue(null ,id ,value, maturityDate);
				break;

			case FixTags.SECURITYSTATUS_INT:
				securityStatus = FixUtils.getTagStringValue(null ,id ,value, securityStatus);
				if (!SecurityStatus.isValid(securityStatus) ) throw new FixSessionException(SessionRejectReason.VALUE_IS_INCORRECT_OUT_OF_RANGE_FOR_THIS_TAG, ("Invalid enumerated value(" + securityStatus + ") for tag").getBytes(), id, new byte[0] );
				break;

			case FixTags.SETTLEONOPENFLAG_INT:
				settleOnOpenFlag = FixUtils.getTagStringValue(null ,id ,value, settleOnOpenFlag);
				break;

			case FixTags.INSTRMTASSIGNMENTMETHOD_INT:
				instrmtAssignmentMethod = FixUtils.getTagCharValue(null ,id ,value );
				break;

			case FixTags.MATURITYTIME_INT:
				maturityTime = FixUtils.getTagStringValue(null ,id ,value, maturityTime);
				break;

			case FixTags.COUPONPAYMENTDATE_INT:
				couponPaymentDate = FixUtils.getTagStringValue(null ,id ,value, couponPaymentDate);
				break;

			case FixTags.RESTRUCTURINGTYPE_INT:
				restructuringType = FixUtils.getTagStringValue(null ,id ,value, restructuringType);
				if (!RestructuringType.isValid(restructuringType) ) throw new FixSessionException(SessionRejectReason.VALUE_IS_INCORRECT_OUT_OF_RANGE_FOR_THIS_TAG, ("Invalid enumerated value(" + restructuringType + ") for tag").getBytes(), id, new byte[0] );
				break;

			case FixTags.SENIORITY_INT:
				seniority = FixUtils.getTagStringValue(null ,id ,value, seniority);
				if (!Seniority.isValid(seniority) ) throw new FixSessionException(SessionRejectReason.VALUE_IS_INCORRECT_OUT_OF_RANGE_FOR_THIS_TAG, ("Invalid enumerated value(" + seniority + ") for tag").getBytes(), id, new byte[0] );
				break;

			case FixTags.NOTIONALPERCENTAGEOUTSTANDING_INT:
				notionalPercentageOutstanding = FixUtils.getTagFloatValue(null ,id ,value);
				break;

			case FixTags.ORIGINALNOTIONALPERCENTAGEOUTSTANDING_INT:
				originalNotionalPercentageOutstanding = FixUtils.getTagFloatValue(null ,id ,value);
				break;

			case FixTags.ATTACHMENTPOINT_INT:
				attachmentPoint = FixUtils.getTagFloatValue(null ,id ,value);
				break;

			case FixTags.DETACHMENTPOINT_INT:
				detachmentPoint = FixUtils.getTagFloatValue(null ,id ,value);
				break;

			case FixTags.ISSUEDATE_INT:
				issueDate = FixUtils.getTagStringValue(null ,id ,value, issueDate);
				break;

			case FixTags.REPOCOLLATERALSECURITYTYPE_INT:
				repoCollateralSecurityType = FixUtils.getTagIntValue(null ,id ,value );
				break;

			case FixTags.REPURCHASETERM_INT:
				repurchaseTerm = FixUtils.getTagIntValue(null ,id ,value );
				break;

			case FixTags.REPURCHASERATE_INT:
				repurchaseRate = FixUtils.getTagFloatValue(null ,id ,value);
				break;

			case FixTags.FACTOR_INT:
				factor = FixUtils.getTagFloatValue(null ,id ,value);
				break;

			case FixTags.CREDITRATING_INT:
				creditRating = FixUtils.getTagStringValue(null ,id ,value, creditRating);
				break;

			case FixTags.INSTRREGISTRY_INT:
				instrRegistry = FixUtils.getTagStringValue(null ,id ,value, instrRegistry);
				break;

			case FixTags.COUNTRYOFISSUE_INT:
				countryOfIssue = FixUtils.getTagStringValue(null ,id ,value, countryOfIssue);
				break;

			case FixTags.STATEORPROVINCEOFISSUE_INT:
				stateOrProvinceOfIssue = FixUtils.getTagStringValue(null ,id ,value, stateOrProvinceOfIssue);
				break;

			case FixTags.LOCALEOFISSUE_INT:
				localeOfIssue = FixUtils.getTagStringValue(null ,id ,value, localeOfIssue);
				break;

			case FixTags.REDEMPTIONDATE_INT:
				redemptionDate = FixUtils.getTagStringValue(null ,id ,value, redemptionDate);
				break;

			case FixTags.STRIKEPRICE_INT:
				strikePrice = FixUtils.getTagFloatValue(null ,id ,value);
				break;

			case FixTags.STRIKECURRENCY_INT:
				strikeCurrency = FixUtils.getTagStringValue(null ,id ,value, strikeCurrency);
				break;

			case FixTags.STRIKEMULTIPLIER_INT:
				strikeMultiplier = FixUtils.getTagFloatValue(null ,id ,value);
				break;

			case FixTags.STRIKEVALUE_INT:
				strikeValue = FixUtils.getTagFloatValue(null ,id ,value);
				break;

			case FixTags.STRIKEPRICEDETERMINATIONMETHOD_INT:
				strikePriceDeterminationMethod = FixUtils.getTagIntValue(null ,id ,value );
				if (!StrikePriceDeterminationMethod.isValid(strikePriceDeterminationMethod) ) throw new FixSessionException(SessionRejectReason.VALUE_IS_INCORRECT_OUT_OF_RANGE_FOR_THIS_TAG, ("Invalid enumerated value(" + strikePriceDeterminationMethod + ") for tag").getBytes(), id, new byte[0] );
				break;

			case FixTags.STRIKEPRICEBOUNDARYMETHOD_INT:
				strikePriceBoundaryMethod = FixUtils.getTagIntValue(null ,id ,value );
				if (!StrikePriceBoundaryMethod.isValid(strikePriceBoundaryMethod) ) throw new FixSessionException(SessionRejectReason.VALUE_IS_INCORRECT_OUT_OF_RANGE_FOR_THIS_TAG, ("Invalid enumerated value(" + strikePriceBoundaryMethod + ") for tag").getBytes(), id, new byte[0] );
				break;

			case FixTags.STRIKEPRICEBOUNDARYPRECISION_INT:
				strikePriceBoundaryPrecision = FixUtils.getTagFloatValue(null ,id ,value);
				break;

			case FixTags.UNDERLYINGPRICEDETERMINATIONMETHOD_INT:
				underlyingPriceDeterminationMethod = FixUtils.getTagIntValue(null ,id ,value );
				if (!UnderlyingPriceDeterminationMethod.isValid(underlyingPriceDeterminationMethod) ) throw new FixSessionException(SessionRejectReason.VALUE_IS_INCORRECT_OUT_OF_RANGE_FOR_THIS_TAG, ("Invalid enumerated value(" + underlyingPriceDeterminationMethod + ") for tag").getBytes(), id, new byte[0] );
				break;

			case FixTags.OPTATTRIBUTE_INT:
				optAttribute = FixUtils.getTagCharValue(null ,id ,value );
				break;

			case FixTags.CONTRACTMULTIPLIER_INT:
				contractMultiplier = FixUtils.getTagFloatValue(null ,id ,value);
				break;

			case FixTags.MINPRICEINCREMENT_INT:
				minPriceIncrement = FixUtils.getTagFloatValue(null ,id ,value);
				break;

			case FixTags.UNITOFMEASURE_INT:
				unitOfMeasure = FixUtils.getTagStringValue(null ,id ,value, unitOfMeasure);
				if (!UnitOfMeasure.isValid(unitOfMeasure) ) throw new FixSessionException(SessionRejectReason.VALUE_IS_INCORRECT_OUT_OF_RANGE_FOR_THIS_TAG, ("Invalid enumerated value(" + unitOfMeasure + ") for tag").getBytes(), id, new byte[0] );
				break;

			case FixTags.TIMEUNIT_INT:
				timeUnit = FixUtils.getTagStringValue(null ,id ,value, timeUnit);
				if (!TimeUnit.isValid(timeUnit) ) throw new FixSessionException(SessionRejectReason.VALUE_IS_INCORRECT_OUT_OF_RANGE_FOR_THIS_TAG, ("Invalid enumerated value(" + timeUnit + ") for tag").getBytes(), id, new byte[0] );
				break;

			case FixTags.MINPRICEINCREMENTAMOUNT_INT:
				minPriceIncrementAmount = FixUtils.getTagFloatValue(null ,id ,value);
				break;

			case FixTags.UNITOFMEASUREQTY_INT:
				unitOfMeasureQty = FixUtils.getTagFloatValue(null ,id ,value);
				break;

			case FixTags.PRICEUNITOFMEASURE_INT:
				priceUnitOfMeasure = FixUtils.getTagStringValue(null ,id ,value, priceUnitOfMeasure);
				break;

			case FixTags.PRICEUNITOFMEASUREQTY_INT:
				priceUnitOfMeasureQty = FixUtils.getTagFloatValue(null ,id ,value);
				break;

			case FixTags.SETTLMETHOD_INT:
				settlMethod = FixUtils.getTagCharValue(null ,id ,value );
				if (!SettlMethod.isValid(settlMethod) ) throw new FixSessionException(SessionRejectReason.VALUE_IS_INCORRECT_OUT_OF_RANGE_FOR_THIS_TAG, ("Invalid enumerated value(" + settlMethod + ") for tag").getBytes(), id, new byte[0] );
				break;

			case FixTags.EXERCISESTYLE_INT:
				exerciseStyle = FixUtils.getTagIntValue(null ,id ,value );
				if (!ExerciseStyle.isValid(exerciseStyle) ) throw new FixSessionException(SessionRejectReason.VALUE_IS_INCORRECT_OUT_OF_RANGE_FOR_THIS_TAG, ("Invalid enumerated value(" + exerciseStyle + ") for tag").getBytes(), id, new byte[0] );
				break;

			case FixTags.OPTPAYOUTAMOUNT_INT:
				optPayoutAmount = FixUtils.getTagFloatValue(null ,id ,value);
				break;

			case FixTags.PRICEQUOTEMETHOD_INT:
				priceQuoteMethod = FixUtils.getTagStringValue(null ,id ,value, priceQuoteMethod);
				if (!PriceQuoteMethod.isValid(priceQuoteMethod) ) throw new FixSessionException(SessionRejectReason.VALUE_IS_INCORRECT_OUT_OF_RANGE_FOR_THIS_TAG, ("Invalid enumerated value(" + priceQuoteMethod + ") for tag").getBytes(), id, new byte[0] );
				break;

			case FixTags.LISTMETHOD_INT:
				listMethod = FixUtils.getTagIntValue(null ,id ,value );
				if (!ListMethod.isValid(listMethod) ) throw new FixSessionException(SessionRejectReason.VALUE_IS_INCORRECT_OUT_OF_RANGE_FOR_THIS_TAG, ("Invalid enumerated value(" + listMethod + ") for tag").getBytes(), id, new byte[0] );
				break;

			case FixTags.CAPPRICE_INT:
				capPrice = FixUtils.getTagFloatValue(null ,id ,value);
				break;

			case FixTags.FLOORPRICE_INT:
				floorPrice = FixUtils.getTagFloatValue(null ,id ,value);
				break;

			case FixTags.PUTORCALL_INT:
				putOrCall = FixUtils.getTagIntValue(null ,id ,value );
				if (!PutOrCall.isValid(putOrCall) ) throw new FixSessionException(SessionRejectReason.VALUE_IS_INCORRECT_OUT_OF_RANGE_FOR_THIS_TAG, ("Invalid enumerated value(" + putOrCall + ") for tag").getBytes(), id, new byte[0] );
				break;

			case FixTags.FLEXIBLEINDICATOR_INT:
				flexibleIndicator = FixUtils.getTagBooleanValue(null ,id ,value );
				break;

			case FixTags.FLEXPRODUCTELIGIBILITYINDICATOR_INT:
				flexProductEligibilityIndicator = FixUtils.getTagBooleanValue(null ,id ,value );
				break;

			case FixTags.VALUATIONMETHOD_INT:
				valuationMethod = FixUtils.getTagStringValue(null ,id ,value, valuationMethod);
				if (!ValuationMethod.isValid(valuationMethod) ) throw new FixSessionException(SessionRejectReason.VALUE_IS_INCORRECT_OUT_OF_RANGE_FOR_THIS_TAG, ("Invalid enumerated value(" + valuationMethod + ") for tag").getBytes(), id, new byte[0] );
				break;

			case FixTags.CONTRACTMULTIPLIERUNIT_INT:
				contractMultiplierUnit = FixUtils.getTagIntValue(null ,id ,value );
				if (!ContractMultiplierUnit.isValid(contractMultiplierUnit) ) throw new FixSessionException(SessionRejectReason.VALUE_IS_INCORRECT_OUT_OF_RANGE_FOR_THIS_TAG, ("Invalid enumerated value(" + contractMultiplierUnit + ") for tag").getBytes(), id, new byte[0] );
				break;

			case FixTags.FLOWSCHEDULETYPE_INT:
				flowScheduleType = FixUtils.getTagIntValue(null ,id ,value );
				if (!FlowScheduleType.isValid(flowScheduleType) ) throw new FixSessionException(SessionRejectReason.VALUE_IS_INCORRECT_OUT_OF_RANGE_FOR_THIS_TAG, ("Invalid enumerated value(" + flowScheduleType + ") for tag").getBytes(), id, new byte[0] );
				break;

			case FixTags.OPTPAYOUTTYPE_INT:
				optPayoutType = FixUtils.getTagIntValue(null ,id ,value );
				if (!OptPayoutType.isValid(optPayoutType) ) throw new FixSessionException(SessionRejectReason.VALUE_IS_INCORRECT_OUT_OF_RANGE_FOR_THIS_TAG, ("Invalid enumerated value(" + optPayoutType + ") for tag").getBytes(), id, new byte[0] );
				break;

			case FixTags.COUPONRATE_INT:
				couponRate = FixUtils.getTagFloatValue(null ,id ,value);
				break;

			case FixTags.SECURITYEXCHANGE_INT:
				securityExchange = FixUtils.getTagStringValue(null ,id ,value, securityExchange);
				break;

			case FixTags.POSITIONLIMIT_INT:
				positionLimit = FixUtils.getTagIntValue(null ,id ,value );
				break;

			case FixTags.NTPOSITIONLIMIT_INT:
				nTPositionLimit = FixUtils.getTagIntValue(null ,id ,value );
				break;

			case FixTags.ISSUER_INT:
				issuer = FixUtils.getTagStringValue(null ,id ,value, issuer);
				break;

			case FixTags.ENCODEDISSUERLEN_INT:
				encodedIssuerLen = FixUtils.getTagIntValue(null ,id ,value );
				break;

			case FixTags.ENCODEDISSUER_INT:
				encodedIssuer = FixUtils.getTagStringValue(null ,id ,value, encodedIssuer);
				break;

			case FixTags.SECURITYDESC_INT:
				securityDesc = FixUtils.getTagStringValue(null ,id ,value, securityDesc);
				break;

			case FixTags.ENCODEDSECURITYDESCLEN_INT:
				encodedSecurityDescLen = FixUtils.getTagIntValue(null ,id ,value );
				break;

			case FixTags.ENCODEDSECURITYDESC_INT:
				encodedSecurityDesc = FixUtils.getTagStringValue(null ,id ,value, encodedSecurityDesc);
				break;

			case FixTags.SECURITYXMLLEN_INT:
				securityXML.getAll( FixTags.SECURITYXMLLEN_INT, value );
				break;

			case FixTags.POOL_INT:
				pool = FixUtils.getTagStringValue(null ,id ,value, pool);
				break;

			case FixTags.CONTRACTSETTLMONTH_INT:
				contractSettlMonth = FixUtils.getTagStringValue(null ,id ,value, contractSettlMonth);
				break;

			case FixTags.CPPROGRAM_INT:
				cPProgram = FixUtils.getTagIntValue(null ,id ,value );
				if (!CPProgram.isValid(cPProgram) ) throw new FixSessionException(SessionRejectReason.VALUE_IS_INCORRECT_OUT_OF_RANGE_FOR_THIS_TAG, ("Invalid enumerated value(" + cPProgram + ") for tag").getBytes(), id, new byte[0] );
				break;

			case FixTags.CPREGTYPE_INT:
				cPRegType = FixUtils.getTagStringValue(null ,id ,value, cPRegType);
				break;

			case FixTags.NOEVENTS_INT:
				evntGrp.noEvents = FixUtils.getTagIntValue(null, FixTags.NOEVENTS_INT, value );
				evntGrp.getAll(evntGrp.noEvents, value );
				break;

			case FixTags.DATEDDATE_INT:
				datedDate = FixUtils.getTagStringValue(null ,id ,value, datedDate);
				break;

			case FixTags.INTERESTACCRUALDATE_INT:
				interestAccrualDate = FixUtils.getTagStringValue(null ,id ,value, interestAccrualDate);
				break;

			case FixTags.NOINSTRUMENTPARTIES_INT:
				instrumentParties.noInstrumentParties = FixUtils.getTagIntValue(null, FixTags.NOINSTRUMENTPARTIES_INT, value );
				instrumentParties.getAll(instrumentParties.noInstrumentParties, value );
				break;

			case FixTags.NOCOMPLEXEVENTS_INT:
				complexEvents.noComplexEvents = FixUtils.getTagIntValue(null, FixTags.NOCOMPLEXEVENTS_INT, value );
				complexEvents.getAll(complexEvents.noComplexEvents, value );
				break;

			// we will always endup with unknown tag, unread and return to upper layer in hierarchy
			default:
				id = checkRequiredTags();
				if (id > 0) throw new FixSessionException(SessionRejectReason.REQUIRED_TAG_MISSING, "Required tag missing".getBytes(), id, new byte[0] );

				buf.position( lastTagPosition );
				return;

			}

			lastTagPosition = buf.position();

		} while ( ( id = FixUtils.getTagId( buf ) ) >= 0 );

		buf.position(startTagPosition);

	}

	private int checkRequiredTags() {
		int tag = -1;

		return tag;

	}
	@Override
	public boolean isSet()
	{
		if (FixUtils.isSet(symbol)) return true;
		if (FixUtils.isSet(symbolSfx)) return true;
		if (FixUtils.isSet(securityID)) return true;
		if (FixUtils.isSet(securityIDSource)) return true;
		if (FixUtils.isSet(secAltIDGrp.noSecurityAltID)) return true;
		if (FixUtils.isSet(product)) return true;
		if (FixUtils.isSet(securityGroup)) return true;
		if (FixUtils.isSet(productComplex)) return true;
		if (FixUtils.isSet(cFICode)) return true;
		if (FixUtils.isSet(securityType)) return true;
		if (FixUtils.isSet(securitySubType)) return true;
		if (FixUtils.isSet(maturityMonthYear)) return true;
		if (FixUtils.isSet(maturityDate)) return true;
		if (FixUtils.isSet(securityStatus)) return true;
		if (FixUtils.isSet(settleOnOpenFlag)) return true;
		if (FixUtils.isSet(instrmtAssignmentMethod)) return true;
		if (FixUtils.isSet(maturityTime)) return true;
		if (FixUtils.isSet(couponPaymentDate)) return true;
		if (FixUtils.isSet(restructuringType)) return true;
		if (FixUtils.isSet(seniority)) return true;
		if (FixUtils.isSet(notionalPercentageOutstanding)) return true;
		if (FixUtils.isSet(originalNotionalPercentageOutstanding)) return true;
		if (FixUtils.isSet(attachmentPoint)) return true;
		if (FixUtils.isSet(detachmentPoint)) return true;
		if (FixUtils.isSet(issueDate)) return true;
		if (FixUtils.isSet(repoCollateralSecurityType)) return true;
		if (FixUtils.isSet(repurchaseTerm)) return true;
		if (FixUtils.isSet(repurchaseRate)) return true;
		if (FixUtils.isSet(factor)) return true;
		if (FixUtils.isSet(creditRating)) return true;
		if (FixUtils.isSet(instrRegistry)) return true;
		if (FixUtils.isSet(countryOfIssue)) return true;
		if (FixUtils.isSet(stateOrProvinceOfIssue)) return true;
		if (FixUtils.isSet(localeOfIssue)) return true;
		if (FixUtils.isSet(redemptionDate)) return true;
		if (FixUtils.isSet(strikePrice)) return true;
		if (FixUtils.isSet(strikeCurrency)) return true;
		if (FixUtils.isSet(strikeMultiplier)) return true;
		if (FixUtils.isSet(strikeValue)) return true;
		if (FixUtils.isSet(strikePriceDeterminationMethod)) return true;
		if (FixUtils.isSet(strikePriceBoundaryMethod)) return true;
		if (FixUtils.isSet(strikePriceBoundaryPrecision)) return true;
		if (FixUtils.isSet(underlyingPriceDeterminationMethod)) return true;
		if (FixUtils.isSet(optAttribute)) return true;
		if (FixUtils.isSet(contractMultiplier)) return true;
		if (FixUtils.isSet(minPriceIncrement)) return true;
		if (FixUtils.isSet(unitOfMeasure)) return true;
		if (FixUtils.isSet(timeUnit)) return true;
		if (FixUtils.isSet(minPriceIncrementAmount)) return true;
		if (FixUtils.isSet(unitOfMeasureQty)) return true;
		if (FixUtils.isSet(priceUnitOfMeasure)) return true;
		if (FixUtils.isSet(priceUnitOfMeasureQty)) return true;
		if (FixUtils.isSet(settlMethod)) return true;
		if (FixUtils.isSet(exerciseStyle)) return true;
		if (FixUtils.isSet(optPayoutAmount)) return true;
		if (FixUtils.isSet(priceQuoteMethod)) return true;
		if (FixUtils.isSet(listMethod)) return true;
		if (FixUtils.isSet(capPrice)) return true;
		if (FixUtils.isSet(floorPrice)) return true;
		if (FixUtils.isSet(putOrCall)) return true;
		if (FixUtils.isSet(flexibleIndicator)) return true;
		if (FixUtils.isSet(flexProductEligibilityIndicator)) return true;
		if (FixUtils.isSet(valuationMethod)) return true;
		if (FixUtils.isSet(contractMultiplierUnit)) return true;
		if (FixUtils.isSet(flowScheduleType)) return true;
		if (FixUtils.isSet(optPayoutType)) return true;
		if (FixUtils.isSet(couponRate)) return true;
		if (FixUtils.isSet(securityExchange)) return true;
		if (FixUtils.isSet(positionLimit)) return true;
		if (FixUtils.isSet(nTPositionLimit)) return true;
		if (FixUtils.isSet(issuer)) return true;
		if (FixUtils.isSet(encodedIssuerLen)) return true;
		if (FixUtils.isSet(encodedIssuer)) return true;
		if (FixUtils.isSet(securityDesc)) return true;
		if (FixUtils.isSet(encodedSecurityDescLen)) return true;
		if (FixUtils.isSet(encodedSecurityDesc)) return true;
		if (FixUtils.isSet(securityXML.securityXMLLen)) return true;
		if (FixUtils.isSet(pool)) return true;
		if (FixUtils.isSet(contractSettlMonth)) return true;
		if (FixUtils.isSet(cPProgram)) return true;
		if (FixUtils.isSet(cPRegType)) return true;
		if (FixUtils.isSet(evntGrp.noEvents)) return true;
		if (FixUtils.isSet(datedDate)) return true;
		if (FixUtils.isSet(interestAccrualDate)) return true;
		if (FixUtils.isSet(instrumentParties.noInstrumentParties)) return true;
		if (FixUtils.isSet(complexEvents.noComplexEvents)) return true;
		return false;
	}
	@Override
	public void encode( ByteBuffer out )
	{
		if (FixUtils.isSet(symbol)) FixUtils.putFixTag( out, FixTags.SYMBOL_INT, symbol, 0, Utils.lastIndexTrim(symbol, (byte)0) );
		if (FixUtils.isSet(symbolSfx)) FixUtils.putFixTag( out, FixTags.SYMBOLSFX_INT, symbolSfx, 0, Utils.lastIndexTrim(symbolSfx, (byte)0) );
		if (FixUtils.isSet(securityID)) FixUtils.putFixTag( out, FixTags.SECURITYID_INT, securityID, 0, Utils.lastIndexTrim(securityID, (byte)0) );
		if (FixUtils.isSet(securityIDSource)) FixUtils.putFixTag( out, FixTags.SECURITYIDSOURCE_INT, securityIDSource, 0, Utils.lastIndexTrim(securityIDSource, (byte)0) );
		if (FixUtils.isSet(secAltIDGrp.noSecurityAltID)) secAltIDGrp.encode( out );
		if (FixUtils.isSet(product)) FixUtils.putFixTag( out, FixTags.PRODUCT_INT, product);
		if (FixUtils.isSet(securityGroup)) FixUtils.putFixTag( out, FixTags.SECURITYGROUP_INT, securityGroup, 0, Utils.lastIndexTrim(securityGroup, (byte)0) );
		if (FixUtils.isSet(productComplex)) FixUtils.putFixTag( out, FixTags.PRODUCTCOMPLEX_INT, productComplex, 0, Utils.lastIndexTrim(productComplex, (byte)0) );
		if (FixUtils.isSet(cFICode)) FixUtils.putFixTag( out, FixTags.CFICODE_INT, cFICode, 0, Utils.lastIndexTrim(cFICode, (byte)0) );
		if (FixUtils.isSet(securityType)) FixUtils.putFixTag( out, FixTags.SECURITYTYPE_INT, securityType, 0, Utils.lastIndexTrim(securityType, (byte)0) );
		if (FixUtils.isSet(securitySubType)) FixUtils.putFixTag( out, FixTags.SECURITYSUBTYPE_INT, securitySubType, 0, Utils.lastIndexTrim(securitySubType, (byte)0) );
		if (FixUtils.isSet(maturityMonthYear)) FixUtils.putFixTag( out, FixTags.MATURITYMONTHYEAR_INT, maturityMonthYear);
		if (FixUtils.isSet(maturityDate)) FixUtils.putFixTag( out, FixTags.MATURITYDATE_INT, maturityDate);
		if (FixUtils.isSet(securityStatus)) FixUtils.putFixTag( out, FixTags.SECURITYSTATUS_INT, securityStatus, 0, Utils.lastIndexTrim(securityStatus, (byte)0) );
		if (FixUtils.isSet(settleOnOpenFlag)) FixUtils.putFixTag( out, FixTags.SETTLEONOPENFLAG_INT, settleOnOpenFlag, 0, Utils.lastIndexTrim(settleOnOpenFlag, (byte)0) );
		if (FixUtils.isSet(instrmtAssignmentMethod)) FixUtils.putFixTag( out, FixTags.INSTRMTASSIGNMENTMETHOD_INT, instrmtAssignmentMethod );
		if (FixUtils.isSet(maturityTime)) FixUtils.putFixTag( out, FixTags.MATURITYTIME_INT, maturityTime);
		if (FixUtils.isSet(couponPaymentDate)) FixUtils.putFixTag( out, FixTags.COUPONPAYMENTDATE_INT, couponPaymentDate);
		if (FixUtils.isSet(restructuringType)) FixUtils.putFixTag( out, FixTags.RESTRUCTURINGTYPE_INT, restructuringType, 0, Utils.lastIndexTrim(restructuringType, (byte)0) );
		if (FixUtils.isSet(seniority)) FixUtils.putFixTag( out, FixTags.SENIORITY_INT, seniority, 0, Utils.lastIndexTrim(seniority, (byte)0) );
		if (FixUtils.isSet(notionalPercentageOutstanding)) FixUtils.putFixFloatTag( out, FixTags.NOTIONALPERCENTAGEOUTSTANDING_INT, notionalPercentageOutstanding);
		if (FixUtils.isSet(originalNotionalPercentageOutstanding)) FixUtils.putFixFloatTag( out, FixTags.ORIGINALNOTIONALPERCENTAGEOUTSTANDING_INT, originalNotionalPercentageOutstanding);
		if (FixUtils.isSet(attachmentPoint)) FixUtils.putFixFloatTag( out, FixTags.ATTACHMENTPOINT_INT, attachmentPoint);
		if (FixUtils.isSet(detachmentPoint)) FixUtils.putFixFloatTag( out, FixTags.DETACHMENTPOINT_INT, detachmentPoint);
		if (FixUtils.isSet(issueDate)) FixUtils.putFixTag( out, FixTags.ISSUEDATE_INT, issueDate);
		if (FixUtils.isSet(repoCollateralSecurityType)) FixUtils.putFixTag( out, FixTags.REPOCOLLATERALSECURITYTYPE_INT, repoCollateralSecurityType);
		if (FixUtils.isSet(repurchaseTerm)) FixUtils.putFixTag( out, FixTags.REPURCHASETERM_INT, repurchaseTerm);
		if (FixUtils.isSet(repurchaseRate)) FixUtils.putFixFloatTag( out, FixTags.REPURCHASERATE_INT, repurchaseRate);
		if (FixUtils.isSet(factor)) FixUtils.putFixFloatTag( out, FixTags.FACTOR_INT, factor);
		if (FixUtils.isSet(creditRating)) FixUtils.putFixTag( out, FixTags.CREDITRATING_INT, creditRating, 0, Utils.lastIndexTrim(creditRating, (byte)0) );
		if (FixUtils.isSet(instrRegistry)) FixUtils.putFixTag( out, FixTags.INSTRREGISTRY_INT, instrRegistry, 0, Utils.lastIndexTrim(instrRegistry, (byte)0) );
		if (FixUtils.isSet(countryOfIssue)) FixUtils.putFixTag( out, FixTags.COUNTRYOFISSUE_INT, countryOfIssue, 0, Utils.lastIndexTrim(countryOfIssue, (byte)0) );
		if (FixUtils.isSet(stateOrProvinceOfIssue)) FixUtils.putFixTag( out, FixTags.STATEORPROVINCEOFISSUE_INT, stateOrProvinceOfIssue, 0, Utils.lastIndexTrim(stateOrProvinceOfIssue, (byte)0) );
		if (FixUtils.isSet(localeOfIssue)) FixUtils.putFixTag( out, FixTags.LOCALEOFISSUE_INT, localeOfIssue, 0, Utils.lastIndexTrim(localeOfIssue, (byte)0) );
		if (FixUtils.isSet(redemptionDate)) FixUtils.putFixTag( out, FixTags.REDEMPTIONDATE_INT, redemptionDate);
		if (FixUtils.isSet(strikePrice)) FixUtils.putFixFloatTag( out, FixTags.STRIKEPRICE_INT, strikePrice);
		if (FixUtils.isSet(strikeCurrency)) FixUtils.putFixTag( out, FixTags.STRIKECURRENCY_INT, strikeCurrency, 0, Utils.lastIndexTrim(strikeCurrency, (byte)0) );
		if (FixUtils.isSet(strikeMultiplier)) FixUtils.putFixFloatTag( out, FixTags.STRIKEMULTIPLIER_INT, strikeMultiplier);
		if (FixUtils.isSet(strikeValue)) FixUtils.putFixFloatTag( out, FixTags.STRIKEVALUE_INT, strikeValue);
		if (FixUtils.isSet(strikePriceDeterminationMethod)) FixUtils.putFixTag( out, FixTags.STRIKEPRICEDETERMINATIONMETHOD_INT, strikePriceDeterminationMethod);
		if (FixUtils.isSet(strikePriceBoundaryMethod)) FixUtils.putFixTag( out, FixTags.STRIKEPRICEBOUNDARYMETHOD_INT, strikePriceBoundaryMethod);
		if (FixUtils.isSet(strikePriceBoundaryPrecision)) FixUtils.putFixFloatTag( out, FixTags.STRIKEPRICEBOUNDARYPRECISION_INT, strikePriceBoundaryPrecision);
		if (FixUtils.isSet(underlyingPriceDeterminationMethod)) FixUtils.putFixTag( out, FixTags.UNDERLYINGPRICEDETERMINATIONMETHOD_INT, underlyingPriceDeterminationMethod);
		if (FixUtils.isSet(optAttribute)) FixUtils.putFixTag( out, FixTags.OPTATTRIBUTE_INT, optAttribute );
		if (FixUtils.isSet(contractMultiplier)) FixUtils.putFixFloatTag( out, FixTags.CONTRACTMULTIPLIER_INT, contractMultiplier);
		if (FixUtils.isSet(minPriceIncrement)) FixUtils.putFixFloatTag( out, FixTags.MINPRICEINCREMENT_INT, minPriceIncrement);
		if (FixUtils.isSet(unitOfMeasure)) FixUtils.putFixTag( out, FixTags.UNITOFMEASURE_INT, unitOfMeasure, 0, Utils.lastIndexTrim(unitOfMeasure, (byte)0) );
		if (FixUtils.isSet(timeUnit)) FixUtils.putFixTag( out, FixTags.TIMEUNIT_INT, timeUnit, 0, Utils.lastIndexTrim(timeUnit, (byte)0) );
		if (FixUtils.isSet(minPriceIncrementAmount)) FixUtils.putFixTag( out, FixTags.MINPRICEINCREMENTAMOUNT_INT, minPriceIncrementAmount);
		if (FixUtils.isSet(unitOfMeasureQty)) FixUtils.putFixFloatTag( out, FixTags.UNITOFMEASUREQTY_INT, unitOfMeasureQty);
		if (FixUtils.isSet(priceUnitOfMeasure)) FixUtils.putFixTag( out, FixTags.PRICEUNITOFMEASURE_INT, priceUnitOfMeasure, 0, Utils.lastIndexTrim(priceUnitOfMeasure, (byte)0) );
		if (FixUtils.isSet(priceUnitOfMeasureQty)) FixUtils.putFixFloatTag( out, FixTags.PRICEUNITOFMEASUREQTY_INT, priceUnitOfMeasureQty);
		if (FixUtils.isSet(settlMethod)) FixUtils.putFixTag( out, FixTags.SETTLMETHOD_INT, settlMethod );
		if (FixUtils.isSet(exerciseStyle)) FixUtils.putFixTag( out, FixTags.EXERCISESTYLE_INT, exerciseStyle);
		if (FixUtils.isSet(optPayoutAmount)) FixUtils.putFixTag( out, FixTags.OPTPAYOUTAMOUNT_INT, optPayoutAmount);
		if (FixUtils.isSet(priceQuoteMethod)) FixUtils.putFixTag( out, FixTags.PRICEQUOTEMETHOD_INT, priceQuoteMethod, 0, Utils.lastIndexTrim(priceQuoteMethod, (byte)0) );
		if (FixUtils.isSet(listMethod)) FixUtils.putFixTag( out, FixTags.LISTMETHOD_INT, listMethod);
		if (FixUtils.isSet(capPrice)) FixUtils.putFixFloatTag( out, FixTags.CAPPRICE_INT, capPrice);
		if (FixUtils.isSet(floorPrice)) FixUtils.putFixFloatTag( out, FixTags.FLOORPRICE_INT, floorPrice);
		if (FixUtils.isSet(putOrCall)) FixUtils.putFixTag( out, FixTags.PUTORCALL_INT, putOrCall);
		if (FixUtils.isSet(flexibleIndicator)) FixUtils.putFixTag( out, FixTags.FLEXIBLEINDICATOR_INT, flexibleIndicator?(byte)'Y':(byte)'N' );
		if (FixUtils.isSet(flexProductEligibilityIndicator)) FixUtils.putFixTag( out, FixTags.FLEXPRODUCTELIGIBILITYINDICATOR_INT, flexProductEligibilityIndicator?(byte)'Y':(byte)'N' );
		if (FixUtils.isSet(valuationMethod)) FixUtils.putFixTag( out, FixTags.VALUATIONMETHOD_INT, valuationMethod, 0, Utils.lastIndexTrim(valuationMethod, (byte)0) );
		if (FixUtils.isSet(contractMultiplierUnit)) FixUtils.putFixTag( out, FixTags.CONTRACTMULTIPLIERUNIT_INT, contractMultiplierUnit);
		if (FixUtils.isSet(flowScheduleType)) FixUtils.putFixTag( out, FixTags.FLOWSCHEDULETYPE_INT, flowScheduleType);
		if (FixUtils.isSet(optPayoutType)) FixUtils.putFixTag( out, FixTags.OPTPAYOUTTYPE_INT, optPayoutType);
		if (FixUtils.isSet(couponRate)) FixUtils.putFixFloatTag( out, FixTags.COUPONRATE_INT, couponRate);
		if (FixUtils.isSet(securityExchange)) FixUtils.putFixTag( out, FixTags.SECURITYEXCHANGE_INT, securityExchange, 0, Utils.lastIndexTrim(securityExchange, (byte)0) );
		if (FixUtils.isSet(positionLimit)) FixUtils.putFixTag( out, FixTags.POSITIONLIMIT_INT, positionLimit);
		if (FixUtils.isSet(nTPositionLimit)) FixUtils.putFixTag( out, FixTags.NTPOSITIONLIMIT_INT, nTPositionLimit);
		if (FixUtils.isSet(issuer)) FixUtils.putFixTag( out, FixTags.ISSUER_INT, issuer, 0, Utils.lastIndexTrim(issuer, (byte)0) );
		if (FixUtils.isSet(encodedIssuerLen)) FixUtils.putFixTag( out, FixTags.ENCODEDISSUERLEN_INT, encodedIssuerLen);
		if (FixUtils.isSet(encodedIssuer)) FixUtils.putFixTag( out, FixTags.ENCODEDISSUER_INT, encodedIssuer, 0, Utils.lastIndexTrim(encodedIssuer, (byte)0) );
		if (FixUtils.isSet(securityDesc)) FixUtils.putFixTag( out, FixTags.SECURITYDESC_INT, securityDesc, 0, Utils.lastIndexTrim(securityDesc, (byte)0) );
		if (FixUtils.isSet(encodedSecurityDescLen)) FixUtils.putFixTag( out, FixTags.ENCODEDSECURITYDESCLEN_INT, encodedSecurityDescLen);
		if (FixUtils.isSet(encodedSecurityDesc)) FixUtils.putFixTag( out, FixTags.ENCODEDSECURITYDESC_INT, encodedSecurityDesc, 0, Utils.lastIndexTrim(encodedSecurityDesc, (byte)0) );
		if (FixUtils.isSet(securityXML.securityXMLLen)) securityXML.encode( out );
		if (FixUtils.isSet(pool)) FixUtils.putFixTag( out, FixTags.POOL_INT, pool, 0, Utils.lastIndexTrim(pool, (byte)0) );
		if (FixUtils.isSet(contractSettlMonth)) FixUtils.putFixTag( out, FixTags.CONTRACTSETTLMONTH_INT, contractSettlMonth);
		if (FixUtils.isSet(cPProgram)) FixUtils.putFixTag( out, FixTags.CPPROGRAM_INT, cPProgram);
		if (FixUtils.isSet(cPRegType)) FixUtils.putFixTag( out, FixTags.CPREGTYPE_INT, cPRegType, 0, Utils.lastIndexTrim(cPRegType, (byte)0) );
		if (FixUtils.isSet(evntGrp.noEvents)) evntGrp.encode( out );
		if (FixUtils.isSet(datedDate)) FixUtils.putFixTag( out, FixTags.DATEDDATE_INT, datedDate);
		if (FixUtils.isSet(interestAccrualDate)) FixUtils.putFixTag( out, FixTags.INTERESTACCRUALDATE_INT, interestAccrualDate);
		if (FixUtils.isSet(instrumentParties.noInstrumentParties)) instrumentParties.encode( out );
		if (FixUtils.isSet(complexEvents.noComplexEvents)) complexEvents.encode( out );
	}
	/**
	 * If you use toString for any other purpose than administrative printout.
	 * You will end up in nifelheim!
	**/
	@Override
	public String toString() {
		char sep = '\n';
		if (Boolean.getBoolean("fix.useOneLiner")) sep = ( byte )0x01;

		String s = "";

			if (FixUtils.isSet(symbol)) s += "Symbol(55)=" + new String(symbol) + sep;
			if (FixUtils.isSet(symbolSfx)) s += "SymbolSfx(65)=" + new String(symbolSfx) + sep;
			if (FixUtils.isSet(securityID)) s += "SecurityID(48)=" + new String(securityID) + sep;
			if (FixUtils.isSet(securityIDSource)) s += "SecurityIDSource(22)=" + new String(securityIDSource) + sep;
			if (FixUtils.isSet(secAltIDGrp.noSecurityAltID)) s += secAltIDGrp.toString();
			if (FixUtils.isSet(product)) s += "Product(460)=" + String.valueOf(product) + sep;
			if (FixUtils.isSet(securityGroup)) s += "SecurityGroup(1151)=" + new String(securityGroup) + sep;
			if (FixUtils.isSet(productComplex)) s += "ProductComplex(1227)=" + new String(productComplex) + sep;
			if (FixUtils.isSet(cFICode)) s += "CFICode(461)=" + new String(cFICode) + sep;
			if (FixUtils.isSet(securityType)) s += "SecurityType(167)=" + new String(securityType) + sep;
			if (FixUtils.isSet(securitySubType)) s += "SecuritySubType(762)=" + new String(securitySubType) + sep;
			if (FixUtils.isSet(maturityMonthYear)) s += "MaturityMonthYear(200)=" + new String(maturityMonthYear) + sep;
			if (FixUtils.isSet(maturityDate)) s += "MaturityDate(541)=" + new String(maturityDate) + sep;
			if (FixUtils.isSet(securityStatus)) s += "SecurityStatus(965)=" + new String(securityStatus) + sep;
			if (FixUtils.isSet(settleOnOpenFlag)) s += "SettleOnOpenFlag(966)=" + new String(settleOnOpenFlag) + sep;
			if (FixUtils.isSet(instrmtAssignmentMethod)) s += "InstrmtAssignmentMethod(1049)=" + String.valueOf(instrmtAssignmentMethod) + sep;
			if (FixUtils.isSet(maturityTime)) s += "MaturityTime(1079)=" + new String(maturityTime) + sep;
			if (FixUtils.isSet(couponPaymentDate)) s += "CouponPaymentDate(224)=" + new String(couponPaymentDate) + sep;
			if (FixUtils.isSet(restructuringType)) s += "RestructuringType(1449)=" + new String(restructuringType) + sep;
			if (FixUtils.isSet(seniority)) s += "Seniority(1450)=" + new String(seniority) + sep;
			if (FixUtils.isSet(notionalPercentageOutstanding)) s += "NotionalPercentageOutstanding(1451)=" + String.valueOf(notionalPercentageOutstanding) + sep;
			if (FixUtils.isSet(originalNotionalPercentageOutstanding)) s += "OriginalNotionalPercentageOutstanding(1452)=" + String.valueOf(originalNotionalPercentageOutstanding) + sep;
			if (FixUtils.isSet(attachmentPoint)) s += "AttachmentPoint(1457)=" + String.valueOf(attachmentPoint) + sep;
			if (FixUtils.isSet(detachmentPoint)) s += "DetachmentPoint(1458)=" + String.valueOf(detachmentPoint) + sep;
			if (FixUtils.isSet(issueDate)) s += "IssueDate(225)=" + new String(issueDate) + sep;
			if (FixUtils.isSet(repoCollateralSecurityType)) s += "RepoCollateralSecurityType(239)=" + String.valueOf(repoCollateralSecurityType) + sep;
			if (FixUtils.isSet(repurchaseTerm)) s += "RepurchaseTerm(226)=" + String.valueOf(repurchaseTerm) + sep;
			if (FixUtils.isSet(repurchaseRate)) s += "RepurchaseRate(227)=" + String.valueOf(repurchaseRate) + sep;
			if (FixUtils.isSet(factor)) s += "Factor(228)=" + String.valueOf(factor) + sep;
			if (FixUtils.isSet(creditRating)) s += "CreditRating(255)=" + new String(creditRating) + sep;
			if (FixUtils.isSet(instrRegistry)) s += "InstrRegistry(543)=" + new String(instrRegistry) + sep;
			if (FixUtils.isSet(countryOfIssue)) s += "CountryOfIssue(470)=" + new String(countryOfIssue) + sep;
			if (FixUtils.isSet(stateOrProvinceOfIssue)) s += "StateOrProvinceOfIssue(471)=" + new String(stateOrProvinceOfIssue) + sep;
			if (FixUtils.isSet(localeOfIssue)) s += "LocaleOfIssue(472)=" + new String(localeOfIssue) + sep;
			if (FixUtils.isSet(redemptionDate)) s += "RedemptionDate(240)=" + new String(redemptionDate) + sep;
			if (FixUtils.isSet(strikePrice)) s += "StrikePrice(202)=" + String.valueOf(strikePrice) + sep;
			if (FixUtils.isSet(strikeCurrency)) s += "StrikeCurrency(947)=" + new String(strikeCurrency) + sep;
			if (FixUtils.isSet(strikeMultiplier)) s += "StrikeMultiplier(967)=" + String.valueOf(strikeMultiplier) + sep;
			if (FixUtils.isSet(strikeValue)) s += "StrikeValue(968)=" + String.valueOf(strikeValue) + sep;
			if (FixUtils.isSet(strikePriceDeterminationMethod)) s += "StrikePriceDeterminationMethod(1478)=" + String.valueOf(strikePriceDeterminationMethod) + sep;
			if (FixUtils.isSet(strikePriceBoundaryMethod)) s += "StrikePriceBoundaryMethod(1479)=" + String.valueOf(strikePriceBoundaryMethod) + sep;
			if (FixUtils.isSet(strikePriceBoundaryPrecision)) s += "StrikePriceBoundaryPrecision(1480)=" + String.valueOf(strikePriceBoundaryPrecision) + sep;
			if (FixUtils.isSet(underlyingPriceDeterminationMethod)) s += "UnderlyingPriceDeterminationMethod(1481)=" + String.valueOf(underlyingPriceDeterminationMethod) + sep;
			if (FixUtils.isSet(optAttribute)) s += "OptAttribute(206)=" + String.valueOf(optAttribute) + sep;
			if (FixUtils.isSet(contractMultiplier)) s += "ContractMultiplier(231)=" + String.valueOf(contractMultiplier) + sep;
			if (FixUtils.isSet(minPriceIncrement)) s += "MinPriceIncrement(969)=" + String.valueOf(minPriceIncrement) + sep;
			if (FixUtils.isSet(unitOfMeasure)) s += "UnitOfMeasure(996)=" + new String(unitOfMeasure) + sep;
			if (FixUtils.isSet(timeUnit)) s += "TimeUnit(997)=" + new String(timeUnit) + sep;
			if (FixUtils.isSet(minPriceIncrementAmount)) s += "MinPriceIncrementAmount(1146)=" + String.valueOf(minPriceIncrementAmount) + sep;
			if (FixUtils.isSet(unitOfMeasureQty)) s += "UnitOfMeasureQty(1147)=" + String.valueOf(unitOfMeasureQty) + sep;
			if (FixUtils.isSet(priceUnitOfMeasure)) s += "PriceUnitOfMeasure(1191)=" + new String(priceUnitOfMeasure) + sep;
			if (FixUtils.isSet(priceUnitOfMeasureQty)) s += "PriceUnitOfMeasureQty(1192)=" + String.valueOf(priceUnitOfMeasureQty) + sep;
			if (FixUtils.isSet(settlMethod)) s += "SettlMethod(1193)=" + String.valueOf(settlMethod) + sep;
			if (FixUtils.isSet(exerciseStyle)) s += "ExerciseStyle(1194)=" + String.valueOf(exerciseStyle) + sep;
			if (FixUtils.isSet(optPayoutAmount)) s += "OptPayoutAmount(1195)=" + String.valueOf(optPayoutAmount) + sep;
			if (FixUtils.isSet(priceQuoteMethod)) s += "PriceQuoteMethod(1196)=" + new String(priceQuoteMethod) + sep;
			if (FixUtils.isSet(listMethod)) s += "ListMethod(1198)=" + String.valueOf(listMethod) + sep;
			if (FixUtils.isSet(capPrice)) s += "CapPrice(1199)=" + String.valueOf(capPrice) + sep;
			if (FixUtils.isSet(floorPrice)) s += "FloorPrice(1200)=" + String.valueOf(floorPrice) + sep;
			if (FixUtils.isSet(putOrCall)) s += "PutOrCall(201)=" + String.valueOf(putOrCall) + sep;
			if (FixUtils.isSet(flexibleIndicator)) s += "FlexibleIndicator(1244)=" + String.valueOf(flexibleIndicator) + sep;
			if (FixUtils.isSet(flexProductEligibilityIndicator)) s += "FlexProductEligibilityIndicator(1242)=" + String.valueOf(flexProductEligibilityIndicator) + sep;
			if (FixUtils.isSet(valuationMethod)) s += "ValuationMethod(1197)=" + new String(valuationMethod) + sep;
			if (FixUtils.isSet(contractMultiplierUnit)) s += "ContractMultiplierUnit(1435)=" + String.valueOf(contractMultiplierUnit) + sep;
			if (FixUtils.isSet(flowScheduleType)) s += "FlowScheduleType(1439)=" + String.valueOf(flowScheduleType) + sep;
			if (FixUtils.isSet(optPayoutType)) s += "OptPayoutType(1482)=" + String.valueOf(optPayoutType) + sep;
			if (FixUtils.isSet(couponRate)) s += "CouponRate(223)=" + String.valueOf(couponRate) + sep;
			if (FixUtils.isSet(securityExchange)) s += "SecurityExchange(207)=" + new String(securityExchange) + sep;
			if (FixUtils.isSet(positionLimit)) s += "PositionLimit(970)=" + String.valueOf(positionLimit) + sep;
			if (FixUtils.isSet(nTPositionLimit)) s += "NTPositionLimit(971)=" + String.valueOf(nTPositionLimit) + sep;
			if (FixUtils.isSet(issuer)) s += "Issuer(106)=" + new String(issuer) + sep;
			if (FixUtils.isSet(encodedIssuerLen)) s += "EncodedIssuerLen(348)=" + String.valueOf(encodedIssuerLen) + sep;
			if (FixUtils.isSet(encodedIssuer)) s += "EncodedIssuer(349)=" + new String(encodedIssuer) + sep;
			if (FixUtils.isSet(securityDesc)) s += "SecurityDesc(107)=" + new String(securityDesc) + sep;
			if (FixUtils.isSet(encodedSecurityDescLen)) s += "EncodedSecurityDescLen(350)=" + String.valueOf(encodedSecurityDescLen) + sep;
			if (FixUtils.isSet(encodedSecurityDesc)) s += "EncodedSecurityDesc(351)=" + new String(encodedSecurityDesc) + sep;
			if (FixUtils.isSet(securityXML.securityXMLLen)) s += securityXML.toString();
			if (FixUtils.isSet(pool)) s += "Pool(691)=" + new String(pool) + sep;
			if (FixUtils.isSet(contractSettlMonth)) s += "ContractSettlMonth(667)=" + new String(contractSettlMonth) + sep;
			if (FixUtils.isSet(cPProgram)) s += "CPProgram(875)=" + String.valueOf(cPProgram) + sep;
			if (FixUtils.isSet(cPRegType)) s += "CPRegType(876)=" + new String(cPRegType) + sep;
			if (FixUtils.isSet(evntGrp.noEvents)) s += evntGrp.toString();
			if (FixUtils.isSet(datedDate)) s += "DatedDate(873)=" + new String(datedDate) + sep;
			if (FixUtils.isSet(interestAccrualDate)) s += "InterestAccrualDate(874)=" + new String(interestAccrualDate) + sep;
			if (FixUtils.isSet(instrumentParties.noInstrumentParties)) s += instrumentParties.toString();
			if (FixUtils.isSet(complexEvents.noComplexEvents)) s += complexEvents.toString();
		return s;

	}

	@Override
	public boolean equals(Object o) {
		if (! ( o instanceof FixInstrument)) return false;

			FixInstrument msg = (FixInstrument) o;

		if (!Utils.equals( symbol, msg.symbol)) return false;

		if (!Utils.equals( symbolSfx, msg.symbolSfx)) return false;

		if (!Utils.equals( securityID, msg.securityID)) return false;

		if (!Utils.equals( securityIDSource, msg.securityIDSource)) return false;

		if (!secAltIDGrp.equals(msg.secAltIDGrp)) return false;

		if (!( product==msg.product)) return false;

		if (!Utils.equals( securityGroup, msg.securityGroup)) return false;

		if (!Utils.equals( productComplex, msg.productComplex)) return false;

		if (!Utils.equals( cFICode, msg.cFICode)) return false;

		if (!Utils.equals( securityType, msg.securityType)) return false;

		if (!Utils.equals( securitySubType, msg.securitySubType)) return false;

		if (!Utils.equals( maturityMonthYear, msg.maturityMonthYear)) return false;

		if (!Utils.equals( securityStatus, msg.securityStatus)) return false;

		if (!Utils.equals( settleOnOpenFlag, msg.settleOnOpenFlag)) return false;

		if (!( instrmtAssignmentMethod==msg.instrmtAssignmentMethod)) return false;

		if (!Utils.equals( restructuringType, msg.restructuringType)) return false;

		if (!Utils.equals( seniority, msg.seniority)) return false;

		if (!( notionalPercentageOutstanding==msg.notionalPercentageOutstanding)) return false;

		if (!( originalNotionalPercentageOutstanding==msg.originalNotionalPercentageOutstanding)) return false;

		if (!( attachmentPoint==msg.attachmentPoint)) return false;

		if (!( detachmentPoint==msg.detachmentPoint)) return false;

		if (!( repoCollateralSecurityType==msg.repoCollateralSecurityType)) return false;

		if (!( repurchaseTerm==msg.repurchaseTerm)) return false;

		if (!( repurchaseRate==msg.repurchaseRate)) return false;

		if (!( factor==msg.factor)) return false;

		if (!Utils.equals( creditRating, msg.creditRating)) return false;

		if (!Utils.equals( instrRegistry, msg.instrRegistry)) return false;

		if (!Utils.equals( countryOfIssue, msg.countryOfIssue)) return false;

		if (!Utils.equals( stateOrProvinceOfIssue, msg.stateOrProvinceOfIssue)) return false;

		if (!Utils.equals( localeOfIssue, msg.localeOfIssue)) return false;

		if (!( strikePrice==msg.strikePrice)) return false;

		if (!Utils.equals( strikeCurrency, msg.strikeCurrency)) return false;

		if (!( strikeMultiplier==msg.strikeMultiplier)) return false;

		if (!( strikeValue==msg.strikeValue)) return false;

		if (!( strikePriceDeterminationMethod==msg.strikePriceDeterminationMethod)) return false;

		if (!( strikePriceBoundaryMethod==msg.strikePriceBoundaryMethod)) return false;

		if (!( strikePriceBoundaryPrecision==msg.strikePriceBoundaryPrecision)) return false;

		if (!( underlyingPriceDeterminationMethod==msg.underlyingPriceDeterminationMethod)) return false;

		if (!( optAttribute==msg.optAttribute)) return false;

		if (!( contractMultiplier==msg.contractMultiplier)) return false;

		if (!( minPriceIncrement==msg.minPriceIncrement)) return false;

		if (!Utils.equals( unitOfMeasure, msg.unitOfMeasure)) return false;

		if (!Utils.equals( timeUnit, msg.timeUnit)) return false;

		if (!( minPriceIncrementAmount==msg.minPriceIncrementAmount)) return false;

		if (!( unitOfMeasureQty==msg.unitOfMeasureQty)) return false;

		if (!Utils.equals( priceUnitOfMeasure, msg.priceUnitOfMeasure)) return false;

		if (!( priceUnitOfMeasureQty==msg.priceUnitOfMeasureQty)) return false;

		if (!( settlMethod==msg.settlMethod)) return false;

		if (!( exerciseStyle==msg.exerciseStyle)) return false;

		if (!( optPayoutAmount==msg.optPayoutAmount)) return false;

		if (!Utils.equals( priceQuoteMethod, msg.priceQuoteMethod)) return false;

		if (!( listMethod==msg.listMethod)) return false;

		if (!( capPrice==msg.capPrice)) return false;

		if (!( floorPrice==msg.floorPrice)) return false;

		if (!( putOrCall==msg.putOrCall)) return false;

		if (!( flexibleIndicator==msg.flexibleIndicator)) return false;

		if (!( flexProductEligibilityIndicator==msg.flexProductEligibilityIndicator)) return false;

		if (!Utils.equals( valuationMethod, msg.valuationMethod)) return false;

		if (!( contractMultiplierUnit==msg.contractMultiplierUnit)) return false;

		if (!( flowScheduleType==msg.flowScheduleType)) return false;

		if (!( optPayoutType==msg.optPayoutType)) return false;

		if (!( couponRate==msg.couponRate)) return false;

		if (!Utils.equals( securityExchange, msg.securityExchange)) return false;

		if (!( positionLimit==msg.positionLimit)) return false;

		if (!( nTPositionLimit==msg.nTPositionLimit)) return false;

		if (!Utils.equals( issuer, msg.issuer)) return false;

		if (!( encodedIssuerLen==msg.encodedIssuerLen)) return false;

		if (!Utils.equals( encodedIssuer, msg.encodedIssuer)) return false;

		if (!Utils.equals( securityDesc, msg.securityDesc)) return false;

		if (!( encodedSecurityDescLen==msg.encodedSecurityDescLen)) return false;

		if (!Utils.equals( encodedSecurityDesc, msg.encodedSecurityDesc)) return false;

		if (!securityXML.equals(msg.securityXML)) return false;

		if (!Utils.equals( pool, msg.pool)) return false;

		if (!Utils.equals( contractSettlMonth, msg.contractSettlMonth)) return false;

		if (!( cPProgram==msg.cPProgram)) return false;

		if (!Utils.equals( cPRegType, msg.cPRegType)) return false;

		if (!evntGrp.equals(msg.evntGrp)) return false;

		if (!instrumentParties.equals(msg.instrumentParties)) return false;

		if (!complexEvents.equals(msg.complexEvents)) return false;

		return true;
	}
}
